## OS 功能

![](images/Pasted%20image%2020240928234148.png)

- *中断机制*是操作系统的**核心功能**，必须具备。
- 进程、内存、文件等管理功能是**选择性实现**的，取决于操作系统的应用场景。

#### 作为系统资源的管理者

#### 向上层提供方便易用的服务

#### 接口

##### CLI 命令接口

- **联机/交互式命令**：`CMD` 命令行
- **交互式命令**：`shell命令` 或 `.sh/.bat` 脚本

##### 程序接口

- **用户进程调用接口**：由一组系统调用实现
- **应用程序**：通常通过**库函数**来使用系统调用

##### GUI

- **GUI【图形用户界面】**：应用程序通过 GUI 调用 OS 系统服务

#### 管理者

#### 扩充

##### 抽象

![](images/Pasted%20image%2020240928154609.png)

## OS 四大特征

#### 并发

- **定义**：两个或多个事件在同一时间间隔发生
- **并行**：
  - 多流水线或者多个 CPU 可以实现并行
  - 单核 CPU 是并发，多核 CPU 或多处理器可以并行
- **在同一时间内**：多任务操作系统不需要 CPU 持续做多任务，只需要实现并发即可
- **注**：不需要实际并行

> [! ] 并行并发的区别
>
> - 并行的 " 同时 " 是同一时刻可以多个进程在运行 (running)
> - 并发的 " 同时 " 是经过上下文快速切换的并行

#### 共享

- **定义**：在一段时间内，无论宏观还是微观都不可同时访问
- **互斥资源共享**：
  - 在一段时间内，无论宏观微观都不可以同时访问
  - 互斥式共享：进程 A 访问完才可以释放，才允许另一个进程访问
  - 独占资源/临界资源：一段时间内只允许一个进程访问
  - 如打印机、磁带机
- **同时访问方式**：
  - 在一段时间内，宏观上同时访问，微观上分时访问
- **OS 对共享资源的管理**：串行和并发的情况通过 OS 进行控制和协调

#### 虚拟

- **定义**：把一个物理实体变为若干逻辑上的虚拟物
  - **虚拟处理器**：利用多道程序设计技术把一个物理上的 CPU 虚拟成多个逻辑上的 CPU，通过**并发**实现
  - **虚拟内存【虚拟存储器】**：把物理存储器转为虚拟存储器，以从**逻辑上**扩充存储器容量
  - **虚拟外部设备**：通过虚拟 I/O 设备（如 Spooling 技术）

#### 异步

- **定义**：指令执行不可预知的速度和时间的特性

## 操作系统的发展和分类

#### 手工操作

- **特点**：需要大量时间进行人工处理，输入输出以及计算机计算的时候几乎没有
- **缺点**：用户独占全部资源，CPU 等待手工操作，资源利用率低，CPU 利用不充分，响应时间长

#### 脱机阶段

#### 批处理阶段【无交互性】

##### 单道批处理

 ![](images/Pasted%20image%2020240929184306.png)

- 引入脱机输入输出技术
- 内存中只有一道程序
- 一批程序自动执行
- 程序之间**串行**执行
- 无须人工干预

##### 多道批处理

 ![](images/Pasted%20image%2020240929184323.png)

- 操作系统开始出现
- 内存中多道程序，多个程序交替运行
- 轮流占用 CPU，提高资源利用率和系统可靠性
- **优点**：实现**并发**，且不需要多 CPU
  - 轮流独占 CPU：因此程序的执行过程存在不确定性
  - 不一定需要多 CPU
- 比单道系统资源利用率高，但吞吐量不稳定
- **缺点**：响应时间长，不提供人机交互

#### 分时操作系统【有交互性】

- 实现了人机交互，多用户可在很短的时间内获得响应
- 将 CPU 时间划分为时间片分配给不同程序
- **浪费一定的资源利用率来完成分时操作**
- 处理系统的关键是 **交互性**

#### 实时操作系统【有一定交互性、但是人与系统的交互仅限于访问系统中某些特定的专用服务程序】

- **硬实时**：所有任务必须在约定时间内完成
- **软实时**：时间是系统设计中的关键因素
- **目标**：**可预测性** 和 **及时性**

## 操作系统的运行环境

### 处理器运行模式

#### 特权指令 / 非特权指令

> [! ] 一个 ISA 包括用户级指令和特权指令

- **特权指令**：指不允许用户直接使用的指令，只能在 **内核态** 执行
  - eg: 管理硬件设备、进程管理和调度、内存管理、文件系统管理、中断处理、设备驱动程序的执行、系统调用的执行

- **非特权指令**：指允许用户直接使用的指令，但不能直接访问系统中的软硬件资源，仅限于访问用户的虚拟地址空间
  - eg: 应用程序的执行、调用库函数、系统调用请求、进程间通信（管道、共享内存、内存使用）

> [! ] 非特权指令设计的初衷是为了防止用户程序对系统的破坏

#### 内核态和用户态

- **用户态**：用户程序运行的状态，`PSW = 0`（目态）
- **内核态**：系统内核运行的状态，`PSW = 1`（管态）
- **中断机制**：中断是用户态和内核态转换的**唯一**途径

> OS 通过 CPU 中的 **PSW** 来区分两态

![内核态和用户态](images/Pasted%20image%2020240927022027.png)

- `内核态 -> 用户态`：执行一条特权指令——修改 PSW 的标志位为 " 用户态 "，这个动作意味着操作系统将主动让出 CPU 使用权

- `用户态 -> 内核态`：由 " 中断 " 引发，由硬件和操作系统内核协作完成，触发中断信号意味着操作系统将进入内核态处理中断事件

> [! ] 命令解释程序（通常指 Shell，例如 Bash 或 PowerShell）通常运行在**用户态**（user mode）
> ![](./images/Pasted%20image%2020241030144538.png)

### OS 管理的部分

- **时钟管理**：
  - 确保系统内时钟同步，时间片轮转调度
  - 操作系统可以为各个事件和资源分配时间戳

- **中断机制**：
  - **定义**：操作系统是基于中断驱动的系统
  - 引入中断技术的初衷是为了提高多道程序运行时的 CPU 利用率，使 CPU 在 I/O 操作期间执行其他指令

  > Operating System is an Interupt driven system

- **原语**：
  - **定义**：处于操作系统的**最底层**
  - **属性**：具有原子性，即一气呵成，不可中断
  - **作用**：运行时间短，调用频繁

#### 资源管理

- 进程管理
- 存储管理
- 文件管理

#### 判断内核区 vs 用户区

- 操作权限

  - **内核区**：只能被操作系统内核访问，通常涉及系统安全、资源管理的结构，如进程控制块 (PCB)。
  - **用户区**：可以被用户进程直接访问，通常包含应用程序的数据和代码。

- 访问方式

  - **系统调用访问**：只能通过系统调用访问的资源一般位于内核区（如文件管理、内存管理等）。
  - **直接访问**：用户进程可以直接访问的数据通常位于用户区（如全局变量、堆内存）。

- 内存分配

  - **内核空间**：操作系统专用的内存空间，包括 PCB、进程调度信息等。
  - **用户空间**：用户进程运行和分配的内存空间，如代码段、堆、栈等。

---

- **进程控制块 (PCB)**：位于内核区。
- **文件描述符**：用户区指针，但引用内核中的内存。
- **系统调用表**：在内核区。
- **用户栈和堆**：在用户区，由用户进程直接操作。

### 系统调用

> [! ] 自陷指令 = trap 指令 = 陷阱指令 = 陷入指令 = 访管指令
> ![](./images/Pasted%20image%2020241030151129.png)
>
> - **访管指令**（例如 x86 架构中的 `INT` 指令，或 ARM 架构中的 `SVC` 指令）是一种特殊指令，主要用于**从用户态切换到内核态**，以便用户程序能够请求操作系统提供的特权服务。这类指令会触发**陷阱（Trap）异常**，将 CPU 从用户态切换到内核态，让操作系统处理用户请求。
> - <font color="#e36c09">访管指令是非特权指令</font>

- **系统调用**是一种特殊类型的**软中断**，它允许**用户态的程序**通过内核定义的接口向**内核态**请求执行某些服务或操作。这些操作通常涉及到对系统资源的访问和管理，比如文件系统、进程控制、网络通信等

- 系统调用是操作系统提供的接口，它在保护模式下运行，确保了用户态程序不能直接访问内核态的资源，避免了系统的崩溃和不安全行为

- 系统调用提供了用户程序和 OS 内核之间的接口
- 应用程序通过请求系统调用来获得 OS 内核的服务

#### 系统调用功能分类

1. **设备管理**: 完成设备的请求或释放，以及设备启动等功能
2. **文件管理**：文件的读、写、创建、删除等功能
3. **内存管理**：内存的分配、回收、已经获取作业占用内存区大小和其实地址
4. **进程控制**：进程的创建、撤销、堵塞、唤醒。eg：fork（）系统调用创建一个子进程
5. **进程通信**：进程间消息的传递或信号传递等功能

---

- 进行堆栈的切换
- 特权级的转换

#### 系统调用过程

![](images/Pasted%20image%2020240927022415.png)
![](images/Pasted%20image%2020241002154846.png)

1. 传递系统调用参数（压栈）
2. 执行 `trap` 指令
3. 执行 `syscall` 服务程序
4. 恢复现场，退出系统调用，返回用户态

##### 用户态与内核态的交互

> [! ] 用户态向内核态的特级切换时机是：用户态下响应中断或异常时

![](images/Pasted%20image%2020240927022357.png)

- 用户代码中的 `read()` 只是一个库函数
- 系统调用指令不会出现在用户代码中，而是**通过软中断进入内核来执行**
- 执行中断/陷阱指令，可以引发陷阱异常，导致 CPU 从用户态进入内核态
- 内核执行完服务程序后，通过 `sysret` 指令恢复 CPU 的中断状态，返回用户态

##### 举例说明

```cpp
int main() {
	int fileDescriptor;
	char buffer[100];

	// 打开文件 （用户态 -> 核心态）
	fileDescriptor = open("file.txt", O_RDONLY);
	
	// (核心态 -> 用户态)

	// 读取文件内容 （用户态 -> 核心态）
	ssize_t bytesRead = read(fileDescriptor, buffer, sizeof(buffer) - 1);
	// (核心态 -> 用户态)

	// 将读取内容添加字符串结束符 （用户态）
	buffer[bytesRead] = '\0';

	// 输出文件内容 （用户态）
	printf("File content: %s\n", buffer);

	// 关闭文件 （用户态 -> 核心态）
	close(fileDescriptor);
	// (核心态 -> 用户态)
	return 0;
}
```

![](images/Pasted%20image%2020240929163931.png)

- 由用户程序触发（动机：请求在 **用户模式** 下无法完成的任务）
- 工作在 **内核模式**
- 由操作系统负责执行
- 执行结束要返回 **用户模式**

#### 系统调用过程

![](./images/Pasted%20image%2020241030155523.png)

- **用户态设置参数**：用户进程在调用系统调用时，首先会在用户态下通过寄存器、栈或特定的内存区域设置好参数。

- **特权级切换**：在进行系统调用后，通过 " 访管指令 " 或者陷入机制实现从用户态切换到内核态。

- **内核态接收参数**：系统进入内核态后，内核会根据预定义的传参方式（寄存器或栈等）获取用户态传入的参数。

- **内核态处理**：完成参数传递后，内核态执行相应的系统调用操作，并返回结果给用户态。

#### 系统调用的开销

- 保护程序上下文
- 第一次调用要建立一个堆栈
- 验证参数 内核代码对用户进程不信任
- 内核态映射到用户态的地址空间 不同进程的切换 需要更新 cr3 寄存器 存放页目录表物理地址

### 中断【见计组总结】

[[../计组/第五章-CPU/中断和异常机制|中断和异常机制]]

## OS 引导

### 主引导记录 MBR

  ![](images/Pasted%20image%2020240927025004.png)

- **位置**：位于磁盘的 0 号扇区。
- **功能**：包含磁盘引导程序和分区表信息。
- **作用**：MBR 记录磁盘的分区信息，并选择一个分区的 PBR 进行加载和执行。

  ![](images/Pasted%20image%2020240927025036.png)

### 分区引导记录 PBR

- **位置**：位于系统分区的 0 号扇区。
- **功能**：
  - **分区引导程序**：负责引导分区内的操作系统。
- **操作系统引导程序**：加载操作系统到内存中。

### 图解过程

![](images/Pasted%20image%2020240927025144.png)
![](images/Pasted%20image%2020241002151633.png)

- MBR 中的标志信息位：告诉主机这个磁盘是不是引导盘（分区中至少有一个分区是活动分区，有操作系统）

- **引导块**

  - 每个分区可以是不同的文件系统，且每个分区都会有引导块，但未必都安装了操作系统。如果安装操作系统，则该分区的引导块为主
  - 如果该磁盘分区有 OS，则引导块不为空；如果没有 OS，则引导块内没有实际内容

1. **CPU 执行自举程序**

   - **读取 ROM**：CPU 从特定内存地址开始执行 ROM 中的引导程序（自举程序）。
   - **硬件自检**：启动 BIOS 程序，对硬件进行自检，检测设备故障并初始化中断向量。

2. **RAM 读取主引导记录（MBR）**

   - 从磁盘的第一个扇区（MBR）读取主引导记录到内存中，执行其中的引导程序，并检查分区表。

3. **RAM 读取活动分区的分区引导记录（PBR）**

   - 从活动分区（即安装了操作系统的分区）读取 PBR，并执行其中的引导程序。

4. **加载操作系统**

   - 从活动分区的根目录中找到并执行操作系统的初始化程序（bootloader），完成系统初始化和启动。

---

> 物理磁盘的存储区域划分

- **过程**：这是在磁盘的物理格式化过程中实现的。
- **提供者**：由磁盘厂商或操作系统的低级工具提供支持。

> 磁盘物理空间划分为逻辑磁盘

- **步骤**：这就是磁盘分区过程，通常在磁盘管理工具中进行，包括创建多个分区（如 C、D 盘）。

> 装入文件系统相关信息

- **过程名称**：此过程被称为逻辑格式化，用于初始化分区的文件系统，使分区能够存储文件和目录信息。

> MBR 的加载逻辑

- **原因**：MBR 包含分区表信息和引导程序，通过分区表中标记的活动分区（安装操作系统的分区）来加载对应的分区引导记录（PBR），并启动操作系统。

> BIOS 的存储位置和介质

- **位置**：存储在外部存储中，而非内存中。
- **存储介质**：位于 ROM（只读存储器）中。
- **原因**：ROM 可以断电后保持数据，确保开机时读取 BIOS 以进行系统初始化和硬件自检。而 RAM 属于易失性存储器，断电后数据会丢失，因此不适合存储 BIOS。

> 图形界面用户态还是内核态

- **答案**：图形界面相关的程序一般运行在用户态。
- **原因**：图形界面程序主要用于用户与系统的交互，通常不需要直接操作硬件或系统资源，因此在用户态即可满足需求。

> 根目录写入磁盘的时机

- **答案**：根目录通常在文件系统初始化或操作系统安装过程中写入磁盘。
- **原因**：文件系统格式化或初始化时创建根目录等基本结构，以便操作系统和用户能够存储和访问文件。

> 鼠标操作反馈的计算机机制

- **机制**：操作系统通过中断机制处理鼠标点击事件，获取操作数据并反馈给用户。
- **反馈原因**：当用户点击鼠标时，硬件生成中断信号，通过中断向量表找到相应的中断服务例程。操作系统捕获该信号并处理，然后更新图形界面或执行对应动作以反馈给用户。
- **涉及过程**：这种反馈机制涉及输入设备驱动的处理过程，主要发生在操作系统的设备管理模块中。

> 程序的内存区域划分

- **代码段、数据段、.bss 段**：这些区域在程序生成可执行文件时就在逻辑上存在，即在编译和链接阶段确定。
- **堆栈区和堆区**：在程序加载和运行时动态分配，大小和位置不在可执行文件中固定。

> 虚拟地址空间的形成时间（静态链接）

- **静态链接**：程序的虚拟地址空间在链接阶段已经确定。静态链接将所有库和依赖项整合到可执行文件中，因此在链接时程序拥有完整的虚拟地址空间布局。

> 数据的物理地址形成时间（静态和动态重定位）

- **静态重定位**：数据的物理地址在程序加载到内存时确定，操作系统在加载时分配物理内存并进行重定位。
- **动态重定位**：数据的物理地址在程序运行时通过地址转换机制动态生成，例如通过页表映射实现。。

> 程序的执行与进程的关系

- **现代操作系统**：程序的执行是通过进程实现的。程序只是包含指令和数据的静态文件，而进程是程序运行时的动态实例，包括程序的代码、数据、CPU 状态和操作系统资源。
- **多任务支持**：一个程序可以对应一个或多个进程，这些进程可以并行或依次运行，以支持操作系统的多任务处理。

> BIOS 加载 MBR 与 CPU 加载 MBR 的联系及类似例子

- **联系**：BIOS 加载 MBR 和 CPU 加载 MBR 描述了同一过程的不同角度。
  - **执行主体**：CPU 读取并执行 BIOS 中的指令，使得 BIOS 将 MBR 加载到内存中。
  - **指令来源**：BIOS 是引导过程的指令来源。
- **类似例子**：操作系统调度进程与 CPU 执行进程：
  - 前者强调操作系统的控制权，而后者强调实际执行的硬件。

### Unified Extensible Firmware Interface (UEFI)

> 统一可扩展固件接口系统

1. 启动过程

   - 与传统 BIOS 的启动过程类似，但更加先进和灵活

2. 电源指令执行

   - 当 UEFI 系统通电后，处理器同样会寻找系统固件中的第一条指令并执行

3. UEFI 固件功能

   - UEFI 固件不仅初始化硬件设备，还提供了一个适于模块化的启动环境，可以加载各种驱动程序，包括操作系统加载前的工具
   - 例如图形用户界面、网络启动、远程诊断等

4. 安全启动机制

   - UEFI 还提供了启动时的安全启动机制，可以验证启动前加载的驱动程序的数字签名，防止恶意软件在启动过程中加载或启动

## 操作系统结构

### 分层法

![](images/Pasted%20image%2020241001115025.png)
**优点**：

- 各层之间只能是**单向依赖或单向调用**
- 容易在现有系统中增加或替换一层而不影响其他层
- 结构清晰，**便于调用和维护**

**缺点**：

- 设计各层比较困难
- 效率较差

### 模块化

![模块化](images/Pasted%20image%2020240927023909.png)

**分块标准**：

![分块标准](images/Pasted%20image%2020240927023928.png)

- **高内聚低耦合**：模块内紧密度更高，模块间紧密度要小

**优点**：

- 提高了系统的**正确性**、**可理解性**和**可维护性**，降低了调试和维护的难度。
- 具有较高的**适应性**：模块可以灵活增减，便于扩展和更新。
- 简化了系统的设计和实现，**编程方便**，便于调试，能够**加速开发过程**。

**缺点**：

- **模块间的接口规范**很难满足对接口的需求

---

> [! ] 分层化和模块化的操作系统谁具有更高的效率？
> **模块化操作系统**具有更高的效率，因为模块化系统中的各模块可以直接进行通信，而分层化系统只能**逐层**进行通信。

---

- *模块化*：**高效率**
- *分层化*：**结构清晰、易维护**

### 宏内核和微内核

#### 宏内核

![宏内核](images/Pasted%20image%2020240927024018.png)

> 操作系统的全部功能模块都在**内核态**

**优点**：

- **性能好**：操作系统的所有功能模块都位于内核态，性能表现良好

**缺点**：

1. **可靠性差**：一个模块的崩溃可能导致整个内核崩溃
2. **维护困难**：随着内核体积的增大，代码变得难以维护，操作系统可能面临 " 软件危机 "

#### 微内核

![微内核](images/Pasted%20image%2020240927024210.png)

- 频繁在核心态和用户态之间切换，**操作系统的开销大**
- 将部分内核的操作系统代码移至内核外，采用客户/服务器模式进行执行
- 采用 " **机制与策略分离** " 的原理
**内核代码**：

- 提供基本的任务管理和硬件抽象。
- 实现核心的通信机制，支持**客户 - 服务器模式**。

**用户的服务请求**：

- 用户进程通过**系统调用**与微内核通信，微内核将请求传递给相应的服务模块执行。

**优点**：

1. **扩展性灵活性好**：允许轻松增加新功能或服务模块
2. **可靠性安全性高**：某个模块崩溃不会影响整个系统
3. **可移植性强**：服务模块和内核能独立演化
4. **分布式计算**

**缺点**：

- **性能较低**：**用户态和内核态的频繁切换**增加了开销，且**模块间通信**导致系统性能有所下降。

#### 小结

| **属性**     | **宏内核**                           | **微内核**                              |
| ---------- | --------------------------------- | ------------------------------------ |
| **性能**     | 高：所有功能模块都在内核态，模块间通信高效，无需频繁上下文切换   | 低：部分服务在用户态，频繁的上下文切换和通信开销较大           |
| **安全性**    | 较差：一个模块崩溃可能导致整个内核崩溃               | 高：非核心模块在用户态运行，单个模块崩溃不会影响整个内核或其他模块    |
| **扩展性**    | 较低：功能模块紧耦合，增加或修改模块需要调整整个内核        | 高：可灵活添加新功能模块，内核结构更加模块化，便于更新和扩展       |
| **可靠性**    | 较低：一个模块的错误可能影响整个系统                | 高：模块隔离性强，单个模块的故障不会导致系统崩溃             |
| **适用场景**   | 适用于性能要求高的系统，如嵌入式系统、实时操作系统         | 适用于需要高安全性、扩展性和可靠性的系统，如分布式系统、现代通用操作系统 |
| **开发维护难度** | 较高：随着内核复杂度增加，维护难度增大，容易出现 " 软件危机 " | 较低：模块化设计易于维护和更新，代码相对独立               |
| **通信方式**   | 内部调用：所有模块在内核态，无需跨态调用              | 客户 - 服务器模式：内核态与用户态通信，采用消息传递机制        |
| **系统开销**   | 较低：无需频繁上下文切换，通信成本低                | 较高：频繁的上下文切换增加了系统开销                   |

### 外核【虚拟性】

- 允许外部**应用程序**直接请求内核的权利
- 外核是提高虚拟机效率的

![预测](images/Pasted%20image%2020240927024215.png)

## 虚拟机

### 第一类虚拟机【运行在裸机上】

![](images/Pasted%20image%2020240930155617.png)

- **第一类虚拟机是运行在裸机上的 OS，拥有最高权限**
- 虚拟机上的操作系统运行在用户态。当需要执行某个特权命令时，实际上是陷入到虚拟机管理程序内执行
- **例**：**VMM** 是唯一一个运行在内核的 OS

- **虚拟内核态**：
  - OS 认为自己运行在内核态，但实际上不是内核态
  - OS 上的用户进程认为自己执行在用户态，事实上也如此
  - 由于没有运行有功能的宿主操作系统的额外开销，裸机虚拟机通常能提供更好的性能和更高的资源利用效率
  - 故裸机 OS 是不允许执行敏感指令的

### 第二类虚拟机【运行在 os 上】

![](images/Pasted%20image%2020240930155636.png)

- 第二类虚拟机是运行在宿主操作系统上的，进程调度、资源分配等会依赖于其他 OS 的

- **客户操作系统进程（如 Windows）**：
  - 第二类虚拟机管理程序
- **宿主操作系统进程**（如 Linux）
  - 宿主操作系统运行在硬件之上（CPU、磁盘、网络、中断等）

- **例**：**VMware**

- 虽然性能上可能不如裸金属虚拟机，但支持性更为简单，且能在不同操作系统间提供更好的硬件兼容性

### 小结

|     项目     |       第一类虚拟机<br>（裸金属架构）|              第二类虚拟机               |
| :--------: | :----------------------------: | :-------------------------------: |
|   **架构**   |      直接运行在裸机硬件上，无需宿主操作系统       |     依赖宿主操作系统，作为宿主 OS 上的应用程序运行     |
|   **权限**   |   虚拟机管理程序（VMM）拥有最高权限，直接控制硬件    |    受宿主操作系统限制，进程调度和资源分配依赖宿主操作系统    |
|   **性能**   |       性能较高，无宿主操作系统的额外开销        |          性能较低，受宿主操作系统影响           |
| **资源利用率**  |       资源利用率高，适合需要高性能的环境        |       资源利用率一般，适合需要较强兼容性的场景        |
| **内核态模拟**  | OS 认为自己运行在内核态，但实际上是 " 虚拟内核态 "  |         OS 运行在宿主操作系统的用户态          |
|  **典型代表**  | VMware ESXi、Microsoft Hyper-V  |   VMware Workstation、VirtualBox   |
| **敏感指令处理** |       裸机虚拟机直接执行敏感指令，提升效率       |     宿主操作系统负责捕获和处理客户 OS 的敏感指令      |
| **硬件兼容性**  | 依赖虚拟机管理程序对硬件的支持，不适合需要频繁硬件更改的场景 | 通过宿主 OS 间接访问硬件，硬件兼容性强，适合频繁更换硬件的场景 |
