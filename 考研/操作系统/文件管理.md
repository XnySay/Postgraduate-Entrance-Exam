## 文件系统基础

### 文件的不同视角

#### 用户眼中的文件

![](./images/Pasted%20image%2020241024234821.png)

- **定义**：文件是目录树中的一个结点，用户通过文件的**绝对路径**和**文件逻辑地址**可以访问对应的信息
- **文件的表现形式**：在用户看来，文件被视为**字符流**，即一系列连续的数据流。用户只需要通过文件名和路径操作文件，而无需了解其底层的存储细节
- **访问方式**：用户提供文件路径及逻辑地址，文件系统通过映射找到文件在磁盘中的物理存储位置

#### 磁盘眼中的文件

- **定义**：文件是由多个**盘块集合**组成的，磁盘以盘块为单位存储数据
- **盘块**：每个盘块是一段连续的磁盘空间，但文件的不同盘块之间在物理存储上不一定是连续的
- **存储方式**：磁盘通过管理盘块来存储文件，盘块的分布方式与用户无关，文件系统负责将这些分散的盘块映射为用户视角的字符流

#### 小结

- **用户视角**：文件被抽象为**字符流**，通过文件路径访问
- **磁盘视角**：文件由多个盘块组成，盘块之间的存储不一定连续

### 文件系统的作用

文件系统简化了用户对文件的操作，负责将用户看到的**字符流**映射为磁盘上的**盘块集合**，让用户可以通过文件名来存取文件，而不需处理底层存储细节

1. **字符流到盘块集合的映射**
   将用户视角的文件（字符流）映射为磁盘的盘块集合

2. **按名存取**
   用户通过文件名访问文件，而无需关心文件的物理存储位置

3. **简化文件管理**
   用户可以方便地创建、删除、读写文件，底层的复杂操作由文件系统处理

### 文件系统功能

1. **目录系统**
   通过**绝对路径**找到文件

2. **逻辑地址到物理地址转换**
   将文件的逻辑地址转换为磁盘上的物理地址

3. **磁盘空间分配**
   管理文件块和空闲空间，使用分配算法

4. **文件管理**
   文件定位、命名和组织

5. **数据安全**
   保障数据可靠性和访问安全

## 文件类型

### 按文件用途分类

1. **系统文件**
   - 由系统软件构成的文件，大多数系统文件只允许用户调用，不允许读和修改

2. **用户文件**
   - 由用户的源代码、目标文件、可执行文件或数据等构成的文件

3. **库文件**
   - 由标准子例程及常用的例程等构成的文件，允许用户调用但不允许修改

### 按文件中数据的形式分类

1. **源文件**
   - 由源程序和数据构成的文件，由终端或输入设备输入的源程序和数据所形成的文件都属于源文件

2. **目标文件**
   - 把源程序经过编译程序编译过，但尚未经过链接程序链接的目标代码所构成的文件，后缀名通常是 ".obj"

3. **可执行文件**
   - 把编译后所产生的目标代码经过链接程序链接后所形成的文件，后缀名通常是 ".exe"

### 按存取控制属性分类

1. **只执行文件**
   - 只允许被核准的用户调用执行，不允许读和写

2. **只读文件**
   - 只允许文件主及被核准的用户去读，不允许写

3. **读写文件**
   - 允许文件主和被核准的用户去读或写的文件

### 按文件的组织形式和处理方式分类

1. **普通文件**
   - 由 ASCII 码或二进制码组成的字符文件

2. **目录文件**
   - 由文件目录组成的文件

3. **特殊文件**
   - 特指系统中的各类 I/O 设备

## 目录系统

### 相关概念

![](./images/Pasted%20image%2020241024234959.png)

#### 目录

![](images/Pasted%20image%2020241013104832.png)

- **目录**：目录是一个特殊的文件，类似于文件夹，包含一组目录项
- **目录项（FCB）**：用于描述目录下的文件信息，包含文件名及对应的**索引节点号**（inode 号）
![](images/Pasted%20image%2020241013104955.png)

#### 目录类型

1. **根目录**
   - 文件系统的最顶层目录
   - 索引节点编号通常是已知的

2. **当前目录**
   - 进程当前正在使用的目录

#### 路径

1. **绝对路径**：文件相对于根目录的路径

2. **相对路径**：文件相对于当前目录的路径

#### inode 链接计数

- **inode 链接计数**：指向同一个 inode 的用户目录项的个数。即有多少目录项指向该文件

### 目录检索流程（根据绝对路径）

1. 从根目录开始，访问根目录文件
2. 根据路径，依次查找对应的文件名和其绑定的目录项
3. 获取目录项中的索引节点号，从索引节点表中找到对应的 inode
4. 如果目录项是一个目录文件，则进入下一层，继续查找
5. 重复上述过程，直到找到路径最底层文件的 inode，进行文件访问

> [! ] 在文件系统中，当找到目标文件时，读取该文件的父目录的过程中，文件的内容已经被读入内存，因此可以直接使用这些数据，而无需再次访问磁盘进行读取操作

### 四种目录结构

#### 单级目录结构

![](images/Pasted%20image%2020240929202915.png)

#### 两级目录结构

![](images/Pasted%20image%2020240929202920.png)

#### 树形目录结构

![](images/Pasted%20image%2020240927031918.png)
![](images/Pasted%20image%2020240927031924.png)

- **树形目录结构** 是一种更为复杂和灵活的组织形式。它允许目录中包含子目录，形成一个层次化的目录树。这种结构支持目录嵌套，适用于 **大型文件系统**
- 树的顶部是根目录，文件系统中的每个文件都有一个 **唯一的路径名**（unique path name）
- 在引用文件时，可以使用 **绝对路径** 或是 **相对路径**
  - 绝对路径：从跟出发的整个目录结构
  - 相对路径 cwd：从当前文件夹出发的整个目录结构

- 优点

  - 灵活的文件组织方式，适合复杂的文件系统
  - 易于扩展，支持多层次文件管理

- 缺点

  - 复杂性增加，特别是路径管理

#### 全局结构 Layout -- 文件在内存中的结构

![](images/Pasted%20image%2020240929203656.png)

## 文件系统结构

![](images/Pasted%20image%2020240929202044.png)
![](images/Pasted%20image%2020241004002650.png)

1. I/O 控制
   - **将输入命令翻译成硬件指令**
   - 包括设备驱动程序和中断处理程序，在内存和磁盘系统之间传输信息

2. 基本/物理文件系统
   - 管理内存缓冲区，保存各种文件系统、目录、数据块缓存
   - **向对应的设备驱动程序发送通用命令，以读取和写入磁盘的物理块。**

3. 文件组织模块
   - 包括空间分配管理器，跟踪没有被分配的块
   - **可以把逻辑地址转为物理地址**
   - 组织文件、文件的逻辑块和物理块

4. 逻辑文件系统
   - **管理目录结构，通过文件控制块维护文件结构、文件保护**
   - 包括文件所有结构，不包括实际数据（文件内容）
   - **管理元数据信息**

### 文件控制块 FCB

- **FCB 的存储单元包含的内容为文件目录**
- **存储方式**：顺序存储，顺序文件
- **包含信息**：
  - 基本信息：文件名、物理位置、逻辑结构、物理结构
  - 存取信息：存取权限
  - 使用信息：建立时间、修改时间

- **元数据是信息，FCB 是信息的载体**
  - **又称：文件元数据**
    - 名称、标志符、类型、位置、大小、保护、时间、日期、用户标识等

- **属性**
  - **文件名**: 同一目录下，文件名称唯一。是用户搜索的主要内容
  - **标识符**: 每个文件都有一个唯一标识，用户不可读
  - **保护信息**: 访问控制信息
  - **其他属性**: 类型、位置、大小、时间

### 索引节点 inode

![](images/Pasted%20image%2020241004002630.png)

> [! ] inode 是 FCB 的一种

> [! ] 索引结点 = 磁盘索引节点 + 附加内容

- **作用**：
  - 放在内存中
  - 存放在内存中：FCB = 文件名 + <索引节点>
  - 因为查空时的数据库没有对应文件的目录项或者用户目录项，必须在内存中开辟 FCB 描述该块，用一个额外的引导扇区可以省略这个过程

> 某种意义上 inode 等同于文件，inode 是文件在文件系统上的元信息（文件本身的元信息是它自己的文件头），要想通过文件系统获得文件的实体，必须先要找到文件的 inode

> **访问 FCB**：

- 故访问一次 FCB 需要**两次访存**
- 但是总体平均来说，因为一个盘块能够存储的 FCB 数目大大增加，所以系统开销减少
- 文件调入内存以前仅存放在磁盘中，调入内存后，复制磁盘索引节点，会增加一些信息变成内存索引结点

- **索引结点编号**: 用于标识内存的索引结点
- **状态**：是否上锁/被修改
- **访问计数**：有多少进程现在正在访问
- **逻辑设备号**：文件所属文件系统的逻辑设备号
- **链接指针**：只想空链表和散列队列的指针

#### 磁盘索引节点

- 每个文件的磁盘索引节点唯一

- 存放位置：外存
- **信息**：
  - **主识别符**：拥有该文件的个人/小组标识符
  - **类型**：普通文件/目录文件/特别文件
  - **存取权限**：各类用户对文件的权限
  - **物理地址**：每个索引节点有 13 个地址，`laddr(0)` ~ `laddr(12)` 可以直接通过直接地址访问所有存储在磁盘上的块号。【**inode**】
    - 0-9 直接地址
    - 10 一级页表
    - 11 二级页表
    - 12 三级页表

  - **文件长度**：所有指向该文件的指针
  - **文件链接数**：链接到该文件的次数
  - **文件存取时间**

## 文件的逻辑结构

从逻辑上来看， 文件的所有数据都是连续分布的

### 无结构文件

- **定义**：由二进制流或字符流组成，又称 "**流式文件**"
- **特点**：流式文件的长度以**字节**为单位，访问时利用读、写指针来指出下一个要访问的字符

### 有结构文件

有结构文件也称**记录式文件**，每个记录都用于描述实体集中的一个实体。记录的长度可分为定长和不定长两类

#### 定长记录

- **定义**：文件中所有记录的长度都是相同的，文件的长度用记录数目表示
- **优点**：
  - **检索速度快**：定长记录能有效地提高检索记录的速度和效率
  - **处理方便**：便于对文件进行处理和修改
- **应用**：这是目前较常用的一种记录格式，适用于需要高效检索和频繁修改的场景

#### 变长记录

- **定义**：文件中各记录的长度不相同，可能是由于记录中包含的数据项数目不同，或者数据项本身的长度不定
- **特点**：
  - **长度可知**：在处理前每个记录的长度都是可知的
  - **检索速度慢**：由于记录长度不固定，无法通过简单计算定位到某条记录的位置，检索速度较慢
  - **处理不便**：变长记录不便于文件的处理和修改
- **应用**：适用于数据结构复杂、记录长度变化较大的场景

#### 小结

- 有结构文件通过记录的组织形式提高了数据管理的效率
- 定长记录适用于需要高效检索和频繁修改的场景，
- 变长记录则适用于数据结构复杂、记录长度变化较大的场景

### 顺序文件

- 文件中的记录一个接一个顺序排列，记录可以是**定长或不定长**
- 物理上存储可以是**顺序存储**或**链式存储**

#### 链式存储

- 只能依次查找

#### 顺序存储

- 可变长记录，只能依次查找
- **定长记录，可以实现随机存储**
  - 串结构，无法快速找到关键字对应记录
  - 顺序结构，可以快速找到对应关键字的记录（如折半查找）

#### 结构类型

1. 串结构: 记录之间的顺序与关键字无关（如按存入时间排列）
2. 顺序结构: 记录之间的顺序按关键字排列

- 默认物理上顺序存储的文件，缺点是**增加，删除记录困难**（串结构简单）

### 索引文件

![](images/Pasted%20image%2020240929163330.png)

- 本身是**定长记录的顺序文件**
- **主要用于对信息处理的及时性要求比较高的场合**（索引号，长度, 指针）
- 可以用不同的数据项建立索引文件
- 关键字顺序排列，可以实现**快速查找**

### 索引顺序文件

![](images/Pasted%20image%2020240929163342.png)

- 在索引文件的基础上，不是一个记录对应一个索引表项，而是**一组记录对应一个索引表项**（**分块的思想**）
- 索引项组成 **（键，地址）**

#### 多级索引顺序文件

![](images/Pasted%20image%2020240929163354.png)

- 高级索引顺序文件索引项为低一级的索引顺序文件，索引项组成**（键，地址）**

## 文件的物理结构

- **物理结构：** 文件的数据是如何存放在外存中的

- **文件块：** 文件的逻辑地址空间被分为一个个**文件块**【**逻辑块号，块内地址**】

- **磁盘块：** 磁盘的存储单元被分为一个个 **块/磁盘块/物理块**

### 连续分配

![](images/Pasted%20image%2020241007154148.png)

- **连续分配**要求**每个文件在磁盘上占有一组连续的块**，文件目录中记录存放该文件在外存中的**起始块号**和**长度**
- `物理块号 = 起始块号 + 逻辑块号`
- **优点：**

  - **顺序读写速度快**，文件是连续存储的，顺序读取文件时无需多次进行磁盘寻道，速度最快
  - 支持**顺序访问**和**随机访问**，逻辑块号可以通过简单的计算直接转换为物理块号
- **缺点：**

  - **扩展不便**：文件增长时，若连续的块不足，需要移动文件到新的位置，移动所有文件块成本较高
  - **空间利用率低**，容易产生碎片，特别是大文件和小文件混合存储时会加重碎片问题

### 链接分配

- 采用离散分配方式，分为隐式链接和显示链接

#### 隐式链接

![](images/Pasted%20image%2020241007154159.png)

**隐式链接**通过离散分配方式存储文件，除了最后一个盘块，每个文件块都存有指向下一个文件块的指针。文件目录记录**起始块号**和**结束块号**，访问时从起始块号开始顺序查找

- **优点：**

  - **方便扩展**：文件增加时，只需要找到一个空闲磁盘块，并把它挂在文件的链尾即可，无需担心是否有连续空闲块
  - **无碎片问题**，空间利用率高
- **缺点：**

  - **只支持顺序访问**：每次查找都需要依次读取前面的块，导致**查找效率低**，特别是访问文件的后续块时，I/O 次数较多
  - 每个磁盘块中存储指向下一个磁盘块的指针，这些指针也消耗一定的存储空间

#### 显示链接（FAT，文件分配表）

![](images/Pasted%20image%2020241007154205.png)

**显示链接**方式将用于链接文件各个物理块的指针存储在**文件分配表**（File Allocation Table, FAT）中。FAT 用于将磁盘块的逻辑编号与物理编号映射在一起，因此文件的物理块号可以通过查表快速找到。

> **FAT 特性和操作**：

- **唯一 FAT 表**：每个磁盘仅设置一张 FAT 表，用于记录文件各个物理块之间的链接。
- **构建时机**：FAT 在磁盘的逻辑格式化时创建。
- **常驻内存**：文件系统挂载时，FAT 表被读入内存并常驻，以加速访问。
- **连续存储**：FAT 的表项在物理上连续存储，且每个表项长度相同，逻辑块号可隐含映射到物理块号。
- **适用场景**：FAT 适合小磁盘空间的系统。FAT 表项的数量取决于文件系统中的磁盘块数。

> **操作流程**：

1. **逻辑到物理映射**：用户给出要访问的逻辑块号时，操作系统通过查找该文件对应的目录项（FCB）找到起始块号。
2. **无需磁盘 I/O**：通过查找内存中的 FAT 表，可以直接找到逻辑块号对应的物理块号，整个过程不需要额外的磁盘读操作。

> **优缺点**：

- **优点**：便于扩展，无碎片问题，支持随机访问。
- **缺点**：FAT 表需要占用存储空间。

> 对于已确定位置的磁盘块，进行不同操作时的磁盘 I/O 次数

- **读取操作**：通常需要 1 次磁盘 I/O，类似于下载文件。由于已知位置，直接读取即可。
- **修改操作**：需要 1 次磁盘 I/O。在已知位置修改内容，只需一次定位和写入。
- **覆盖操作**：也需要 1 次磁盘 I/O。覆盖整个内容，仅需一次定位和写入。

### 索引分配

**索引分配**允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，记录文件的各个逻辑块对应的物理块。索引表存放的磁盘块称为**索引块**，文件数据存放的磁盘块称为**数据块**

![](images/Pasted%20image%2020241007154213.png)

**注：**在显式链接的链式分配方式中，**文件分配表 FAT 是一个磁盘对应一张**。而索引分配方式中，**索引表是一个文件对应一张**

- **支持随机访问**：通过索引表可以直接找到文件的任意逻辑块
- **文件扩展容易**：只需分配一个空闲块，并增加一个索引表项
- **占用存储空间**：索引表需要占用一定的存储空间

#### 链接索引

将多个索引块通过链式结构链接起来

- **优点**：简单方便，索引块可以随时扩展
- **缺点**：访问效率低，需要依次查找多个索引块，导致磁盘 I/O 次数较多

![链接索引示意图](images/Pasted%20image%2020241007154223.png)

#### 多层索引

采用类似于多级页表的结构，将索引块分层

- **优点**：支持大文件，访问效率高。通过 K 层索引结构，访问任意数据块时只需 K + 1 次读写操作
- **缺点**：即使是小文件，访问数据块时也需要多次读磁盘

例如：假设磁盘块大小为 1 KB，一个索引表项占用 4 B，则一个磁盘块最多存储 256 个索引。如果文件使用两层索引结构，则该文件的最大长度为 256 × 256 × 1 KB = 64 MB

要访问文件的第 1026 号逻辑块时：

- 1026 / 256 = 4，第 4 号一级索引块；
- 1026 % 256 = 2，第 2 号二级索引块

#### 混合索引

结合直接地址索引、一级间接索引和多级间接索引

- **直接索引**：直接指向数据块，适合小文件
- **一级间接索引**：指向一个单层索引表，适合中等大小的文件
- **两级间接索引**：指向两层索引表，适合大文件

![混合索引示意图](images/Pasted%20image%2020241007154239.png)

- **优点**：提高小文件的访问效率，避免多次读写操作。对于大文件，多级间接索引支持文件扩展，效率较高

### 总结

![](https://lfool.gitbook.io/~gitbook/image?url=https%3A%2F%2F824295091-files.gitbook.io%2F%7E%2Ffiles%2Fv0%2Fb%2Fgitbook-legacy-files%2Fo%2Fassets%252F-MEmUhsvIFBb8ar2-Um3%252F-MFW3sL0i3Wb-OfTClQ2%252F-MFW3xbmKCfd0RYI3VAB%252Fimage.png%3Falt%3Dmedia%26token%3D0568db29-db2d-4555-8aea-d0a51f2ed5ee&width=768&dpr=4&quality=100&sign=ea8d604b&sv=1)

- **系统打开文件表**
  - 保存一个系统中现在打开的文件，已经打开过多少次，只有一张
  - 表项中包含文件的属性（文件物理地址等）
  - 在 OS 导论中，文件第一次被打开时，会在系统打开文件表建立表项，后续如果再次被别的进程打开不再重复建立
  - 在 Linux/Unix 中，每次使用 `open()` 都会在系统打开文件表建立一个表项

- **进程打开文件表**
  - 保存一个进程打开了哪些文件，记录在进程的 PCB 中
  - 表项中包含文件描述符，指向系统文件打开表表项的指针，进程对文件的读写指针等

## 文件和目录的操作

![](images/Pasted%20image%2020240927031936.png)

> [! ] 文件操作的主体是进程

### 创建文件

- 系统需要从外存中**找到足够的磁盘空间**来存储文件内容
- **创建目录项**，目录项记录了新文件的相关信息（如文件名、外存地址等）
- 在成功分配磁盘空间后，文件可以开始使用

### 删除文件

![](images/Pasted%20image%2020241013113635.png)

#### 无硬链接的文件

- **删除文件的目录项**：从文件所在的目录中删除与该文件对应的目录项
- **删除文件控制块（FCB，File Control Block）**：文件控制块包含文件的元数据信息，删除该文件的 FCB
- **释放与文件相关的内存缓冲区**：操作系统会释放文件相关的缓存资源，回收内存
- **回收文件占用的磁盘空间**：释放文件占用的磁盘块，将其标记为可用以便分配给其他文件

#### 有硬链接的文件

- **修改 FCB 中的文件链接计数**：当文件有硬链接时，删除文件时只会减少文件控制块中的链接计数，而不是直接删除文件
- **保留数据**：当文件的其他硬链接仍存在时，数据不会被删除，只有当链接计数减为 0 时，文件的实际数据才会被删除，释放磁盘空间

### 打开文件

![](images/Pasted%20image%2020241013113316.png)
![](images/Pasted%20image%2020240929204101.png)

- 通过 `open()` 函数打开文件，该函数返回一个文件描述符（`fd`），后续文件的操作都通过该文件描述符完成

  - **`open(pathname, flags, mode)`：**
    - `pathname`：要打开或创建的文件路径
    - `flags`：文件打开模式标志（如 `R` 只读、`W` 只写等）
    - `mode`：如果创建新文件，则指定文件的访问权限

- 打开文件后，所有操作通过文件描述符（`fd`）进行，不再使用文件名

> 工作流程

- 调用 `open()` 时，系统在内存中查找文件的 `inode` 信息。如果在内存中不存在该 `inode`，则需要从外存中将其加载到内存中
- 如果文件已经存在且处于打开状态，系统会递增其 `inode` 计数器，表示该文件又被打开了一次
- 系统会为该文件分配一个新的文件描述符（`fd`）并将其返回

### 读文件

根据文件描述符 `fd` 找到对应的用户打开文件表，从而在系统打开文件表中定位到文件在外存中的位置

> 文件描述符是一种**引用文件的指针**，系统为每个打开的文件分配一个唯一的整数作为文件描述符，操作系统的各种文件操作函数都会基于该文件描述符进行

- **`read(fd, buf, count)`：**
  - `fd`：文件描述符，指向打开的文件
  - `buf`：用于存储读取数据的缓冲区指针
  - `count`：读取的字节数
  - **返回值**：成功读取的字节数，若到达文件末尾，返回 0

> 工作流程

- 根据 `fd` 文件描述符，操作系统通过查找进程打开文件表，定位到系统的文件表，再查找到文件的 `inode` 及其所在的磁盘位置
- 系统从磁盘中读取 `count` 个字节的数据，并将其存入缓冲区 `buf` 中

### 写文件

- **`write(fd, buf, count)`**：和 `read()` 的使用方式相似
- **返回值**：成功写入的字节数。如果磁盘空间不足，则可能写入的字节数小于 `count`

> 工作流程

- 根据 `fd` 找到文件在外存中的位置
- 将缓冲区 `buf` 中的数据写入文件，并更新文件的长度和偏移量信息

### 设置文件的读写位置

- 默认情况下，文件的读写是从文件头开始的，且按顺序进行
- 如果需要随机访问文件中的数据，**可以设置文件的读写指针**，使得后续的读写操作从指定位置开始，而不是从文件头开始

### 关闭

- `close(fd)`：**关闭文件并释放相关资源

- `fd`：文件描述符
- 系统回收为该文件分配的内存资源

> 工作流程

- 系统从打开文件表中删除该文件的 `fd` 项
- 文件的 `inode` 访问计数减 1。如果该文件没有其他进程再打开，系统释放与该文件相关的资源
- 如果文件的 `inode` 访问计数为 0 且文件没有其他链接（硬链接、软链接等），则系统将回收文件占用的磁盘空间

## 虚拟文件系统

![[images/page_284.png]]
![[images/page_285.png]]

**VFS 的作用**是通过提供一个**统一的接口**，将不同的文件系统进行**抽象化管理**，从而对上层应用程序屏蔽了底层文件系统的差异性

- **统一接口提供**：

  - VFS 向上层应用程序提供统一的文件操作接口，如 `read()`、`write()`、`open()` 等。应用程序不需要关心底层的文件系统类型，它们只需要调用这些标准接口
- **向下屏蔽差异性**：

  - VFS 向下层文件系统提供统一的接口，来进行文件操作，如文件的打开、读取、写入、格式化等。无论具体使用的是何种文件系统（如 ext 4、NTFS 等），VFS 会屏蔽它们之间的差异性
- **VFS 内存管理**：

  - VFS 维护了一个在内存中的 `vnode` 结构体，用来表示文件系统中的文件。无论文件存储在哪种文件系统中，`vnode` 都会统一管理
![[images/page_286.png]]

### `write()` 调用过程

在 Linux 中，当调用 `write()` 函数时，会经过以下几个步骤：

- **用户空间**：应用程序在用户空间调用 `write()`
- **VFS**：`write()` 调用通过 VFS 中的 `sys_write()` 函数实现。在这个过程中，VFS 会根据文件的类型和文件系统的不同，将请求发送到对应的文件系统
- **具体文件系统**：不同的文件系统有各自的写操作方法，这时 VFS 会调用具体文件系统的写方法来执行写入操作
- **物理层**：最终的写入会通过文件系统的接口与物理介质（硬盘等）进行交互

## 文件的保护

为了防止文件共享导致文件被破坏或未经允许的修改，文件系统需控制用户对文件的存取，解决文件的读、写、执行的许可问题

> [! ] 用户进入系统注册，属于系统级安全管理

### 口令保护

用户请求访问需要提供口令

- 优点：实现简单，开销较小
- 缺点：保存在内存（FCB）中，不安全

### 加密保护

用户对文件进行加密，用户访问需要密钥解密

- 优点：安全性高，系统级安全，登录注册
- 缺点：开销大，加密和解密需要花费时间

### 访问控制（Access Control List，ACL）

- 根据用户身份控制文件的访问权限。文件系统会为每个文件和目录添加访问控制列表（ACL），该列表规定了不同用户的访问权限

> [! ] 必须由系统实现

- 优点：相比于加密保护保密性差，但更灵活

- 缺点：内容太多，可以考虑精简解决问题
- **主要访问对象**
  - **拥有者**: 创建文件的用户
  - **组**：需要共享文件且拥有类似访问的用户
  - **其他**：系统内的所有其他用户

> [! ] 访问文件的限制因素
>
> - 用户访问权限 + 文件属性
> - 用户优先级与能访问文件无关，用户优先级缺点 who first access file！

> **访问矩阵**（R 为读权限，W 为写权限，E 为执行权限）：

| 用户进程 | 文件 F1 | 文件 F2 | 文件 F3 | 文件 F4 |
| ---- | ----- | ----- | ----- | ----- |
| A    | R - - | RW -  |       |       |
| B    |       |       | R - - | RWE   |
| C    |       |       |       | RW -  |

- 访问对于每个文件都是一种**组合**

## 空闲块管理

### 空闲表法

![](images/Pasted%20image%2020240929193627.png)

空闲表法属于**连续分配方式**，为每个文件分配一块连续的存储空间。系统为外存（辅存）上的所有空闲区建立一张**空闲表**，每个空闲区对应一个空闲表项，其中包括*表项序号、该空闲区的第一个盘块号、该区的空闲盘块数*等信息。所有空闲区按其起始盘块号递增的次序排列，形成空闲盘块表。

- **分配磁盘块**：类似于内存管理中的动态分区分配，可采用首次适应、最佳适应、最坏适应等算法来决定为文件分配哪个区间。
- **回收存储空间**：系统在回收用户释放的存储空间时，考虑回收区是否与空闲表中插入点的前区和后区相邻接，对相邻接者应予以合并。

尽管内存分配较少采用连续分配方式，但在外存管理中，这种方式具有较高的分配速度，可减少访问磁盘的 I/O 频率，因此仍然使用。

- **连续分配**：能有效减少磁盘 I/O，提高访问速度。
- **灵活分配策略**：支持不同的分配算法，适应不同的场景。

### 空闲链表法

![](images/Pasted%20image%2020240929202315.png)

空闲链表法是系统在**磁盘的每一个空闲块**中设置一个指针，指向下一个磁盘的空闲块，从而将所有的空闲物理块串联成一条**空闲链表**。

- 系统会设置一个**空闲块首指针**指向第一个空闲块。
- 链表的最后一个空闲块指针为 `NULL`，表示空闲链表结束。

#### 分配空间

1. 系统从空闲块链表的**链首**开始，一块一块地摘下空闲块进行分配。
2. 分配完成后，系统会**修改链首指针**，指向新的链首。

#### 释放空间

- 当释放物理空间时，系统将释放的块插入链表，并**修改链表首指针**为新插入的块。

#### 优缺点

- **优点**：管理简单，空闲块的链接指针隐藏在空闲盘块中，空间需求小。
- **缺点**：每次分配和插入空闲块都需要调整链表，增加了对磁盘的读写操作，对系统效率有一定影响。

空闲块组成链表结构，每个链表节点对应一个空闲区。在分配和回收时，节点的插入、删除和合并操作相对简单，且链表有助于**动态管理**空闲区，尤其在频繁分配和释放时能有效减少碎片。

### 位示图法

![位示图](images/Pasted%20image%2020240929202319.png)

位示图法是一种**反映整个存储空间分配情况的位示图数据结构**。在位示图中，一个二进制位反映一个物理块的分配情况。

- **位为 1** 表示该块已分配。
- **位为 0** 表示该块空闲。

#### 磁盘分配步骤

1. **顺序扫描**：顺序扫描位示图，从中找出一个或一组其值为 0 的二进制位（"0" 表示空闲时）
2. **转换盘块号**：将所找到的一个或一组二进制位转换成与之相应的盘块号。假定位于位示图的第 i 行、第 j 列，则其相应的盘块号按以下公式计算：

   $$
   b = n \times (i-1) + j
   $$

   其中 n 代表每行的位数
3. **修改位示图**：将对应的位示图位置修改为 1，即 `map[i, j] = 1`

#### 磁盘回收步骤

1. **转换行列号**：将回收盘块的盘块号转换成位示图中的行号和列号，转换公式如下：

   $$
   i = \frac{(b-1)}{n} + 1
   $$

   $$
   j = (b-1) \% n + 1
   $$

2. **修改位示图**：将对应的位示图位置修改为 0，即 `map[i, j] = 0`

#### 优缺点

- **优点**：
  - 位示图占用空间小，可以保存在主存中，因此空间的分配与回收速度较快。

- **缺点**：
  - 对于大规模的磁盘来说，位示图会占用较大内存存储空间。

- 位示图利用二进制的一位来表示磁盘中一个盘块的使用情况，当其值为 0 时表示对应的盘块空闲，为 1 时表示已分配
- 磁盘上的所有盘块都有一个二进制位与之对应，这样由所有盘块所对应的位构成一个矩阵
- 通常可用 m x n 个位数来构成位示图，并使 m x n 等于磁盘的总块数，描述为一个二维数组 `map[m, n]`
示磁盘中一个盘块的使用情况（0 表示空闲，1 表示已分配）。由所有盘块的位构成一个矩阵，通常用 m x n 的位数来构成位示图，m x n 等于磁盘的总块数。

- **易于查找相邻空闲盘块**：从位示图中很容易找到一个或一组相邻接的空闲盘块。例如，需要找到 n 个相邻接的空闲盘块，只需在位示图中找出 n 个其值连续为 0 的位即可
- **占用空间少**：位示图很小，占用空间少，可以保存在内存中，使每次进行盘区分配时，无需首先把盘区分配表读入内存

### 成组链接法

![](./images/Pasted%20image%2020241024234917.png)
![](./images/Pasted%20image%2020241022140902.png)

成组链接法是一种结合了**空闲表法**和**空闲链表法**优点的磁盘空闲块管理方法。通过分组方式记录磁盘的空闲块信息，以减少链表的长度，从而提升效率

- **空闲表法**：能快速分配空闲块，但当空闲块较多时，表可能过长
- **空闲链表法**：方便回收和分配空间，但链表可能也过长且效率低

成组链接法在 UNIX 系统中被广泛使用，主要通过 " 超级块 " 管理空闲块

#### 分配空闲块

> **检查空闲块数**：当需要 i 个空闲块时，检查第一个分组的块数是否足够

- **足够**：如果 1 < n，分配第一个分组中的 i 个空闲块，并修改相应数据。例如，上图的成组链接，若需要 5 个空闲块，可以分配 201 ~ 205 号空闲块，并修改超级块的空闲块数量为 95
- **不足够**：如果 i ≥ n，分配第一个分组中的全部空闲块。由于第一个空闲块存放了下一组的信息，因此需要将该块的数据复制到超级块中。例如，上图的成组链接，若需要 95 个空闲块，可以分配 206 ~ 300 号空闲块，并将 300 号块的数据复制到超级块中

#### 回收空闲块

1. **加入超级块**：将空闲块号加入超级块中，修改空闲盘块数，并进行相应的链接
2. **处理满栈**：如果回收空闲块后达到了超级块空闲盘块数的上限，需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组

#### 关键点

- **空闲盘块号栈**：存放了本栈中空闲盘块的数量
- **栈底记录**：记录的是下一个这样的组数据所在的盘块号。如果栈底是 0，就是空闲盘块链的结束标志
- **栈中记录**：除了栈底记录的是空闲盘块号栈，其他记录的都是空闲的盘块
- **互斥访问**：栈是临界资源，需要互斥访问
- **分配盘块**：从栈顶取出空闲盘块号分给用户，然后栈顶指针向下移动一位，记录空闲盘块的数量减 1。若已经到了栈底，就把记录的下一个空闲盘块号栈所在的块调入内存，并把原栈对应的盘块分配出去
- **回收盘块**：若栈满则存入盘块，再找新盘块作为栈底

### FAT

## 共享问题

### 索引节点的两大功能

![](images/Pasted%20image%2020241004002541.png)

#### 文件链接

- **文件链接数**：表示有多少文件目录指向同一个索引节点（inode）。通常与硬链接相关，硬链接是多个文件名指向同一个文件的实现方式

- 特点

 1. **硬链接的文件链接数**：
    - 每当创建一个**硬链接**，链接数就会增加
    - 删除一个硬链接时，链接数会减少
    - 当 `文件链接数 == 0` 时，文件会被操作系统彻底从磁盘上删除

 2. **软链接的文件链接数**：
    - **软链接**（符号链接）本质上是一个独立的文件，它保存目标文件的路径，而不是指向同一个 inode
    - 软链接的**文件链接数恒为 1**，因为它只是一个文件路径的引用，独立于目标文件
    - **删除软链接** 只会删除软链接文件本身，不影响目标文件，目标文件的链接数不会因此减少

- 删除规则

  - **硬链接删除**：
    - 只有当所有硬链接（包括源文件）都被删除，且 `文件链接数 == 0` 时，文件数据才会被真正从磁盘中删除

  - **软链接删除**：
    - 软链接的删除只删除软链接文件本身，不会影响目标文件的链接数或内容

#### 访问计数

当文件被加载到内存中时，操作系统会维护一个**内存索引节点**，记录有多少进程正在访问该文件。这类似于对文件的引用计数

  1. **多进程访问**：
     - 多个进程同时访问同一个文件时，**访问计数**会增加
     - 每当一个进程关闭文件，访问计数就会减少

  2. **内存释放**：
     - 当 `访问计数 == 0` 时，操作系统认为没有进程在使用该文件，文件的内存数据可以被释放，或将数据置换回磁盘以释放内存资源

### 硬链接【基于索引结点的共享方式】

![](images/Pasted%20image%2020240929164144.png)

> 特点

- **同一个 inode**：所有硬链接和源文件共享相同的 inode，表示它们实际上是**同一个文件**，只是有多个名字【**文件共享**】
- **删除条件**：只有当**所有硬链接和源文件**都被删除时，文件内容才会被操作系统彻底删除
- **查找速度**：由于硬链接**直接指向 inode**，查找文件时的速度比软链接快
- **限制**：
  - 硬链接只能在**同一文件系统**内创建，不能跨文件系统
  - 硬链接不能用于**目录链接**，以避免**循环引用**的问题

### 软链接【利用符号链的共享方式】

![](images/Pasted%20image%2020240929164154.png)

- **定义**：软链接（符号链接，symbolic link）是一个**独立的文件**，它保存指向另一个文件的路径，而不直接指向文件的 `inode`。因此，它本身是一个新的文件类型（LINK），而不是文件的另一种名称

> 特点

- **新文件**：软链接是一个新创建的 `LINK` 类型文件，保存的是目标文件的路径

  - 创建一个 `LINK` 类型的新文件

  - `LINK` 中仅保存指向目标文件的路径
     身的链接，这样可能会造成目录循环引用的问题

- **路径链接**：软链接**指向文件的路径**，而不是 inode，因此它可以跨文件系统创建
- **文件的存在情况**：如果目标文件被删除，软链接将变成**失效链接**，在访问时返回错误
- **循环引用风险**：软链接可以指向目录，甚至创建指向自身的链接，可能导致目录循环引用问题

### 例子理解 【硬链接≈引用，软链接≈指针】

- **硬链接 ≈ 引用**：不同名字（硬链接）指向同一个文件，修改或删除其中一个不会影响另一个
- **软链接 ≈ 指针**：软链接是对文件的指针，删除文件后，软链接变成一个失效指针，无法访问数据

### 硬链接 vs 软链接

![](./images/Pasted%20image%2020241019192853.png)

| 特性         | 硬链接                | 软链接                |
| ---------- | ------------------ | ------------------ |
| 是否共享 inode | 是                  | 否（保存文件路径）          |
| 是否能跨文件系统   | 否                  | 是                  |
| 删除源文件的影响   | 源文件和硬链接都要删除，文件才会消失 | 删除源文件后，软链接失效（路径无效）|
| 查找速度       | 快（直接访问 inode）| 相对慢（需要解析路径）|
| 是否能指向目录    | 否                  | 是                  |
| 循环引用风险     | 无                  | 可能出现循环引用           |

### 索引节点的引用计数和系统级打开文件表中的访问计数的区别

- **引用计数**：
  - 与链接和删除文件有关

  - 表示与文件实体（如 inode）对应的目录项（链接）数量。
  - 每当创建一个新的硬链接到文件时，引用计数增加；删除链接时，引用计数减少。
  - 当引用计数为 0 时，文件的数据块可以被系统回收，因为文件不再有任何有效的链接指向它。
- **访问计数**：
  - 与打开关闭文件有关

  - 表示当前有多少个进程打开了该文件。
  - 每次一个新进程打开文件，访问计数增加；进程关闭文件时，访问计数减少。
  - 访问计数用于操作系统内部管理文件的并发访问，而引用计数用于判断文件是否需要被删除。

### 例题

![](images/Pasted%20image%2020240927032002.png)
