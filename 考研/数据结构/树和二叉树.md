## 树的基本概念

### 树的定义

树是 $n(n \geq 0)$ 个结点的有限集。当 $n = 0$ 时，树为空树

- 在任意一个非空树中应满足：
  1. 有且仅有一个特定的称为**根**的结点
  2. 当 $n > 1$ 时，其余结点可分为 $m(m > 0)$ 个互不相交的有限集 $T1, T2, …, Tm$，其中每个集合本身又是一棵树，并且称为**子树**

> [! ] 树是一种递归结构，也是一种分层结构

- 树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱
- 树中所有结点的前驱以及子孙关系唯一且相同

### 基本术语

![树的基本术语](images/Pasted%20image%2020240913193650.png)

- **根结点**：没有父结点的结点，如图中的 A
- **结点的度**：结点的儿女个数

- **树的度**：树中所有结点度的最大值，$$max\{结点的度\} = 树的度$$

- **叶子结点（终端结点）**：没有子结点的结点（度为 0），如图中的 K, L, J 等
- **分支结点（非终端结点）**：度不为 0 的结点，如图中的 B, C, D 等
- **结点的层次**：从根结点开始定义，根为第一层，其子女为第二层，以此类推
- **结点的深度**：从根结点到该结点所经过的边的数目
- **结点的高度**：从该结点到叶结点最长路径的边数
- **树的深度（高度）**：树中所有结点的最大层次数
- **双亲**：结点的直接上级
- **子女**：结点的直接下级
- **兄弟**：同一双亲的结点
- **路径**：从一个结点到另一个结点所经过的结点序列
- **森林**：$m(m \geq 0)$ 棵互不相交的树的集合，删除树的根结点即成森林
  - 给 $m$ 棵独立的树加上一个结点，并将 $m$ 棵树连在此结点上，即构成一棵树

### 树的性质

1. **结点个数**：
   - 树中的结点数 = 所有结点的度数之和 + 1
   - 度为 $m$ 的树中，第 $i$ 层最多有 $m^{i-1}$ 个结点
   - 度为 $m$ 的树中，最多有 $\sum_{i=0}^{h-1} m^i$ 个结点

2. **子树不相交**：树中每个结点的子树不相交

3. **层数**：
   - 度为 $m$ 的树，最多有 $n = \log_m(m(n-1) + 1)$ 层
   - 树的第 $i$ 层至多有 $m^i$ 个结点

4. **树的高度**：
   - 高度为 $h$ 的 $m$ 叉树，最多有 $n = \frac{m^h - 1}{m-1}$ 个结点
   - $n$ 个结点的 $m$ 叉树的高度至多为 $\log_m((m-1)n + 1)$

5. **其他性质**：
   - 树中每个结点到根结点有且仅有一条路径
   - 度为 1 的树是一个链表
   - 树中度为 1 的结点的个数至少为 2

6. **m 叉树**：
   - 每个结点最多有 $m$ 个孩子
   - 任意结点的度 $\leq m$，可以是空树

7. **度为 m 的树**：
   - 任意结点的度 $\leq m$，至少有一个结点度 = $m$
   - 一定是非空树，至少有 $m+1$ 个结点

### 树的其他表示形式

![](images/Pasted%20image%2020241010203635.png)

## 二叉树

### 二叉树的定义

在树定义的基础上加两个条件便可成为二叉树：

1. 每个结点**最多**有两个子树，即不存在度大于 2 的结点 2. 有序树：子树有左右之分，其次序不能任意颠倒

> m 叉树和度为 m 的树的区别：m 叉树中每个结点最多有 m 个孩子，度为 m 的树中每个结点的度 ≤ m

### 二叉树的性质

- 叶子结点数等于度为 2 的结点数加 1- 第 $i$ 层的最大结点数为 $2^{i-1}$- 最大结点数：高度为 $h$ 的二叉树最多有 $2^h - 1$ 个结点 - 最小结点数：高度为 $h$ 的二叉树至少有 $2^{h-1}$ 个结点 - 度为 2 的结点与叶结点的关系：度为 2 的结点数加 1 等于叶子结点数 - 父子关系：编号为奇数的结点的双亲编号为 $\frac{i-1}{2}$，编号为偶数的结点的双亲编号为 $\frac{i}{2} - 1$

### 特殊的二叉树

#### 满二叉树

![满二叉树](images/Pasted%20image%2020240913193956.png)

- 一个高度为 $h$，且含有 $2^h - 1$ 个结点的二叉树称为满二叉树 - 在满二叉树中，除了叶子结点外的所有结点都有且仅有两个子结点，且每一层的结点数都达到最大
- 假设根结点编号为 1。对于编号为 $i$ 的结点：

  - 左孩子编号为 $2i$，即左孩子位于父结点编号的两倍位置 - 右孩子编号为 $2i + 1$，即右孩子位于父结点编号的两倍位置再加 1  - 父结点编号：任意结点 $i$ 的父结点编号为 $\lfloor \frac{i}{2} \rfloor$，即对 $i$ 除以 2 再取整

##### 满二叉树的性质

- 最大结点数：满二叉树中每层的结点数都是最大值，第 $i$ 层有 $2^{i-1}$ 个结点 - 叶子结点位置：所有叶子结点都位于最底层，也即第 $h$ 层 - 结点总数：满二叉树的结点总数为 $2^h - 1$，其中 $h$ 是树的高度 - 结点位置满：满二叉树的每一个结点位置都有元素，没有空位

#### 完全二叉树

![完全二叉树](images/Pasted%20image%2020240913193943.png)

在满二叉树的基础上，最后一层从右到左，删除连续的结点

- 高度为 $h$，有 $n$ 个结点的二叉树，当且仅当其每一个结点都与满二叉树中编号为 1 至 $n$ 的结点一一对应时，称为完全二叉树
特点：

- 对于任意结点，当编号为 $i$，其左孩子在 $2i$ 位置，右孩子在 $2i + 1$ 位置 - 叶子结点只会出现在最后两层，且最后一层叶子结点在左边连续出现 -

##### 完全二叉树的性质

- 双亲结点编号：
  - 若结点编号为 $i$，其双亲结点编号为 $\left\lfloor\frac{i-1}{2}\right\rfloor$  - 当 $i$ 为偶数时，双亲编号为 $\frac{i}{2}-1$；当 $i$ 为奇数时，双亲编号为 $\frac{i-1}{2}$- 子结点编号：
  - 若结点编号为 $i$，其左孩子编号为 $2i$，右孩子编号为 $2i+1$  - 若 $2i \leq n$，结点 $i$ 有左孩子；若 $2i+1 \leq n$，结点 $i$ 有右孩子；否则无对应孩子 - 结点所在层次：编号为 $i$ 的结点所在层次为 $\log_2(i+1)$- 完全二叉树的高度：具有 $n$ 个结点的完全二叉树的高度为 $\log_2(n+1)$ 或 $\log_2 n + 1$

### 二叉树的存储结构

#### 顺序存储结构

![](images/Pasted%20image%2020240913195731.png)

- **从下标 1 开始**：一般约定顺序存储结构从数组的下标 1 开始，根结点存放在数组的第 1 位
- **结点位置的关系**：通过结点的下标，可以直接推导出它的父结点及左右孩子的位置：
  - 若结点的编号为 $i$：
    - 左孩子编号为 $2i$
    - 右孩子编号为 $2i+1$
    - 父结点编号为 $\left\lfloor \frac{i}{2} \right\rfloor$
- **空间浪费**：对于稀疏的树结构，使用顺序存储会浪费空间，特别是当树并非满二叉树时。空缺的结点将会浪费数组中的存储空间

- **优点**

  - 适合存储**满二叉树**和**完全二叉树**，因为这些树的结构紧凑，不会浪费太多空间
  - 通过数组下标可以直接访问任意结点，查询和定位结点的时间复杂度为 $O(1)$，效率高

- **缺点**

  - 对于稀疏的二叉树，需要大量的虚拟空结点来保持树的完整性，这会导致严重的空间浪费

#### 链式存储结构

![](images/Pasted%20image%2020240913195742.png)

链式存储结构采用**链表**的形式存储二叉树中的每个结点，每个结点包含三个部分：

1. **数据域**：存储该结点的数据
2. **左指针域**：指向该结点的左孩子
3. **右指针域**：指向该结点的右孩子

- **每个结点通过指针连接**：通过指针实现父子结点的连接，不需要数组下标来表示结点之间的关系
- **不浪费空间**：只需要为树中的实际结点分配存储空间，不存在多余的虚拟结点，因此适合稀疏的二叉树

- 优点：
  - 空间利用率高，特别适合**稀疏的二叉树**，不会浪费存储空间
  - 插入和删除结点较为方便，不需要重新分配或调整存储空间

- 缺点
  - 访问任意结点的时间复杂度为 $O(n)$，因为需要通过指针遍历才能找到目标结点，访问效率较低

### 二叉树的遍历

![](images/Pasted%20image%2020240913205310.png)

#### 先序遍历 根左右 - DLR

![](images/Pasted%20image%2020241010204659.png)

二叉树的前序遍历顺序为：A−B−D−H−I−E−C−F−J−G−K

#### 中序遍历 左根右 - LDR

![](images/Pasted%20image%2020241010204809.png)

该二叉树的中序遍历顺序为：H−D−I−B−E−A−F−J−C−K−G

#### 后序遍历 左右根 - LRD

![](images/Pasted%20image%2020241010204831.png)

后序遍历顺序为：H−I−D−E−B−J−F−K−G−C−A

#### 层次遍历 队列实现

![](images/Pasted%20image%2020241010204935.png)

该二叉树的层序遍历顺序为：A−B−C−D−E−F−G−H−I−J−K

## 遍历序列的性质

- **中序遍历**：根结点的左边有左子树的所有结点，根结点的右边有右子树的所有结点
- **前序与后序序列**：
  - 当两个相邻结点的前序序列与后序序列顺序不同时为父子
  - 相同时为兄弟
- **后序遍历**：若 a 是 b 的祖先，则后序遍历中一定先遍历 b，后遍历 a
- **先序与后序相反**：如果二叉树的先序序列和后序序列正好相反，则其高度等于其结点数

> **提示**：超级核心内容，选择题和大题都喜欢考。选择题主要考察遍历和二叉树的构造，大题主要考察遍历的应用，如借助遍历实现某些应用，如求二叉树的高度、二叉树的路径

## 遍历序列构造二叉树

- **唯一确定二叉树**：
  - **先序 + 中序**：通过先序确定根节点，再根据中序划分左右子树
  - **后序 + 中序**：通过后序确定根节点，再根据中序划分左右子树
  - **层次遍历 + 中序**：通过层次遍历找到根节点，再根据中序确定左右子树
  - **层次遍历 + 后序**：也是可以唯一确定二叉树的

> **代表例题**：2017-5，2023-4。先根据序列找出根，填进去，根据树形左右子树的结点数来划分左右子树即可

- **不能唯一确定二叉树**：
  - **先序 + 后序**：这种组合无法唯一确定一棵二叉树，因为根节点的位置在这两种遍历序列中没有确定的分界点，可能产生多种不同的二叉树结构

1. **先序 XY，后序 XY 不同祖上**:`X` 和 `Y` 是兄弟节点
2. **先序 XY，中序 YX 不同祖上，X 是 Y 的祖先**:`X` 是 `Y` 的祖先，且 `Y` 位于 `X` 的左子树

## 线索二叉树

![线索二叉树](images/Pasted%20image%2020240913203521.png)
线索二叉树是在普通二叉树的基础上，将每个结点的空指针指向该结点的前驱或后继，从而构建出一个线性序列

#### 规则

- 若无左子树，`lchild` 指向其前驱结点
- 若无右子树，`rchild` 指向其后继结点

#### 结点结构

| lchild   | ltag | data | rtag | rchild   |
| -------- | ---- | ---- | ---- | -------- |
| 左孩子或前驱指针 | 左标志域 | 数据域  | 右标志域 | 右孩子或后继指针 |

- **ltag** 和 **rtag** 标志域的作用：

  - **ltag = 0**：指向左孩子，**ltag = 1**：指向前驱
  - **rtag = 0**：指向右孩子，**rtag = 1**：指向后继

#### 中序线索二叉树的建立

![](images/Pasted%20image%2020240913203540.png)

- **中序遍历规则**：先左子树、后根节点、再右子树

- 步骤

  1. 若 `p->lchild == null`，则将 `p->ltag` 置为 1，`p->lchild` 指向前驱结点
  2. 若 `p->rchild == null`，则将 `p->rtag` 置为 1，`p->rchild` 指向后继结点
  3. 检查 `pre` 的 `rchild` 是否为空，若为空则将 `pre->rtag` 置为 1，`pre->rchild` 指向 `p`

#### 先序线索二叉树

- **先序遍历规则**：根节点 -> 左子树 -> 右子树
- 在先序遍历的过程中，同样遵循左、右子树为空时，分别指向前驱或后继

#### 后序线索二叉树

- **后序遍历规则**：左子树 -> 右子树 -> 根节点
- 后序遍历的线索化步骤同样适用于空的左、右子树

## 森林

### 树的存储结构

#### 双亲表示法

![](images/Pasted%20image%2020240913195407.png)

采用一维数组存储树中的每个结点，每个结点包含一个指向其**双亲结点**的索引。

- **优点**：快速查找双亲结点。
- **缺点**：查找孩子结点需要线性查找。

#### 孩子表示法

![](images/Pasted%20image%2020240913195439.png)

每个结点的**孩子结点**用单链表链接，形成链表结构。

- **优点**：孩子结点不需要顺序存储。
- **缺点**：查找父结点复杂，需要额外信息。表

#### 孩子兄弟表示法

![](images/Pasted%20image%2020240913195513.png)

将多叉树转换为二叉树表示法。每个结点的左指针指向**第一个孩子**，右指针指向**兄弟结点**。

- **优点**：将多叉树转换为二叉树，便于存储和操作。
- **缺点**：查找父结点不便。

> **提示**：如果为每个结点增加一个 `parent` 域来指向父结点，可以简化查找父结点的操作。

### 树和森林的遍历

#### 树的遍历

##### 先根遍历

- 若树非空，先访问**根结点**，再依次遍历根结点的每棵子树。
- **遍历顺序**与该树转换为二叉树后的**先序遍历**相同。

##### 后根遍历

- 若森林非空，先依次遍历每棵树的子树，最后访问根结点。
- **遍历顺序**与该树转换为二叉树后的**中序遍历**相同。

#### 森林的遍历

##### 先序遍历森林

1. 访问**森林中第一棵树**的根结点。
2. 依次**先序遍历**每棵子树。
3. 遍历完第一棵树后，再依次遍历森林中的其他树。

##### 中序遍历森林

1. 访问**森林中第一棵树**的根结点。
2. 依次**中序遍历**第一棵树及其子树。
3. 遍历完第一棵树后，再依次遍历森林中的其他树。

#### 树和森林的遍历与二叉树遍历的对应关系

| 树    | 森林   | **二叉树**  |
| ---- | ---- | -------- |
| 先根遍历 | 先序遍历 | **先序遍历** |
| 后根遍历 | 中序遍历 | **中序遍历** |

## 树、森林与二叉树的转换

### 树转换为二叉树的规则

1. 每个结点的左指针指向其**第一个孩子**。
2. 每个结点的右指针指向其**相邻的右兄弟**。
3. 兄弟结点之间用右指针形成链式连接，表示兄弟关系。

> 转换规则：

- 树的每个结点的第一个孩子在二叉树中对应为该结点的左孩子。
- 树的每个结点的兄弟在二叉树中对应为该结点的右孩子。
- 树的根结点在二叉树中仍然是根结点，不发生改变。

> 在二叉树中：

- 每个结点至多有一个左孩子和一个右孩子。
- 原树的兄弟结点成为二叉树中的右子树的一部分。

### 森林转换为二叉树的简述

![](images/Pasted%20image%2020240913201815.png)
![](images/Pasted%20image%2020240913201909.png)

1. **依次处理每棵树**：对森林中的每棵树，将其与第一个孩子的连线保持不变。
2. **孩子连接转换**：将每个结点的孩子结点转换为以根结点为中心，顺时针旋转 45 度，使其与二叉树结构对应。
3. . **兄弟连接转换**：相邻树的根结点按照兄弟关系相连。

森林中的每棵树的根结点在二叉树中构成根的右子树。
每棵树按转换为二叉树的规则进行转换。
森林的第一棵树的根对应于二叉树的根，后续树的根结点作为兄弟节点。

转换前后遍历的关系
树的先根遍历和二叉树的先序遍历相同。
树的后根遍历和二叉树的中序遍历相同。
森林中的树先序遍历森林对应于二叉树的先序遍历。
中序遍历森林对应于二叉树的中序遍历。

### 二叉树转换为森林的规则

![](images/Pasted%20image%2020240913201840.png)

1. **转换每棵树**：将森林中的每棵树转换为对应的二叉树结构。
2. **兄弟转换**：每棵树的根结点根据兄弟关系连接，形成森林的多个树。
3. **按 45 度旋转**：为了符合表示，按转换规则将每棵树的根结点旋转 45 度连接。
4. **左右子树转换**：二叉树中的左子树和右子树分别转换为对应的子树和兄弟关系。

## 树的应用

### 并查集

#### 支持操作

1. **Union(S, Root1, Root2)**：将集合 S 中的 Root2 并入 Root1，要求 Root1 和 Root2 互不相交，否则不执行合并
   ![](images/Pasted%20image%2020240913203856.png)
   ![](images/Pasted%20image%2020240913203933.png)
2. **Find(X)**：在集合 S 中查找包含 X 的树根结点，并沿路径压缩使路径中所有结点指向根
   ![](images/Pasted%20image%2020240913204018.png)
3. **Initials(n)**：生成含有 n 个单元素集合的并查集

#### 实现

- 用树（森林）表示集合
- 初始时，每个元素自成一个集合，每个元素是一个单独的树
- 合并操作用一个树根指向另一个树根，称为 " 按秩合并 "
- 查找操作沿路径从下向上指向根结点，并将路径上所有结点指向根结点，路径压缩将路径长度变为 O(log n)

##### 并查集的初始化

![](images/Pasted%20image%2020240913203620.png)

###### 用树表示

![](images/Pasted%20image%2020240913203700.png)
![](images/Pasted%20image%2020240913203734.png)

### 二叉排序树 (二叉搜索树)

#### 定义

1. 若左子树非空，则左子树上所有结点的值均小于根结点的值
2. 若右子树非空，则右子树上所有结点的值均大于根结点的值

#### 特性

- 左子树的结点值 < 根结点值 < 右子树的结点值

#### 查找

从根开始，根据值的比较进行查找。若查找值比根值小，则在左子树中查找；若查找值比根值大，则在右子树中查找。若找到，则查找成功；否则，查找失败

- 查找复杂度：
  - 平均情况下时间为 O(log n)
  - 若树退化成线性结构，时间复杂度为 O(n)

#### 插入

1. 若二叉排序树为空，则直接插入结点
2. 若非空，若插入值小于根结点的值，则插入左子树；若插入值大于根结点的值，则插入右子树

#### 删除

1. 若被删除结点无子结点，则直接删除该结点
2. 若被删除结点只有一个子结点，则直接用该子结点替换被删除结点
3. 若被删除结点有两个子结点，则用右子树的最小结点或左子树的最大结点替换被删除结点

### 平衡二叉树

#### 平衡二叉树的定义

在插入和删除二叉树节点时，保证任意节点的左右子树高度差不超过 1 的二叉树称为平衡二叉树。
平衡二叉树是一种特殊的二叉树，在插入和删除节点的过程中，始终保持树的高度差不超过一定限制。
平衡二叉树能够确保在进行查找、插入和删除操作时保持 $O(\log n)$ 的时间复杂度，因此在数据库、操作系统等需要频繁插入和删除操作的场景中具有广泛应用。

#### 平衡二叉树分类

- **AVL 树**：每个节点的左右子树的高度差最多为 1。插入和删除节点后，可能需要多次旋转以恢复平衡。
- **红黑树**：通过颜色属性和旋转操作保持平衡，插入和删除操作的调整较少。
- **Splay 树**：每次访问节点后，通过旋转将该节点移到根节点。

#### 平衡因子

> 在左子树与右子树的高度差为 -1, 0, 1 的条件下，称作平衡二叉树。

$$ \text{平衡因子} = \text{左子树的高度} - \text{右子树的高度} $$

#### 平衡二叉树的查找

- 平均查找长度为 $O(log n)$

#### 平衡二叉树的插入

- 插入节点时，首先按照二叉搜索树的规则插入新节点
- 插入后，检查是否破坏了平衡二叉树的性质，如果破坏了，需要进行旋转操作以恢复平衡
- 旋转操作包括左旋和右旋，通过调整节点位置来保持树的平衡

#### 平衡二叉树的删除

- 删除规则同 BST 一样，如果删除的结点有两个孩子，那么用其右子树的最小值替换该结点，然后删除右子树的最小值结点
- 删除后，需要检查是否破坏了平衡二叉树的性质，如果破坏了，需要进行旋转操作

#### 旋转操作

| 失衡节点的平衡因子 | 子节点的平衡因子 | 应采用的旋转方法 |
| --------- | -------- | -------- |
| >1 （左偏树）| ≥0       | RR       |
| >1 （左偏树）| <0       | LR       |
| <−1 （右偏树）| ≤0       | LL       |
| <−1 （右偏树）| >0       | RL       |

##### LL 平衡旋转（左单旋转）

##### RR 平衡旋转（右单旋转）

##### LR 平衡旋转（先左后右旋转）

##### RL 平衡旋转（先右后左旋转）

### 哈夫曼树

#### 定义

哈夫曼树是带权路径最短的树，也称为最优二叉树。在含有 n 个带权叶结点的二叉树中，具有树的带权路径长度 (WPL) 最小的二叉树称为哈夫曼树

##### 带权路径长度 (WPL) 公式

$$ WPL = \sum_{i=1}^{n} w_i l_i $$

- 其中 $w_i$ 为第 i 个叶结点的权值，$l_i$ 为第 i 个叶结点的路径长度

#### 基本概念

1. **结点路径**：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径
2. **路径长度**：结点路径上的分支数目
3. **树的路径长度**：从树根到每个结点的路径长度之和
4. **结点的带权路径长度**：从该结点到树的根结点之间的路径长度与结点的权值的乘积
5. **树的带权路径长度**：树中所有叶子结点的带权路径长度 (WPL) 之和

#### 构建方法

每次从森林中选出两棵具有最小根结点权值的二叉树，并将其合并成一棵新的二叉树

![哈夫曼树示例](images/Pasted%20image%2020240913203311.png)

#### 性质

- 取两个最小权值树时，小的在左边，大的在右边
- 每个初始结点最终都成为叶结点，权值越大的结点距离根结点越近
- *哈夫曼树所有的元素都在叶子结点上*
- 每次构造都选择 2 棵树作为新结点的孩子，哈夫曼树的结点一定有兄弟
- 初始时有 n 结点，构造过程中共新建 n - 1 个结点，哈夫曼树的结点总数为 2n - 1
- *哈夫曼树不唯一，左右子树可以交换，但 WPL 唯一*

#### 编码

##### 基本概念

- **固定长度编码**：每个符号用相同长度的二进制位表示
- **可变长度编码**：对频繁出现的符号使用短编码，对较不频繁的符号使用较长的编码
- *哈夫曼编码是一种广泛应用于数据压缩的变长编码方式*

- **优点**：显著减少平均编码长度，适用于数据压缩
- **缺点**：构建和维护编码表较为复杂

#### m 叉哈夫曼树

- 每个非叶节点都有 m 个孩子
- **权值**：在哈夫曼树中代表字符的出现频率。
- **叶节点**：树中没有子节点的节点称为叶节点，代表实际需要编码的符号。

---
假设有 $n_0$ 个叶子节点，构建 m 叉树的步骤如下：

1. 计算 $t = (n_0 - 1) \mod (m - 1)$。
   - 若 $t \neq 0$，补充 $m - 1 - t$ 个权重为 0 的节点；
   - 若 $t = 0$，无需增加节点。

2. 每次从所有节点中选取权值最小的 m 个节点作为新节点的子节点，新节点的权值为这些子节点权值之和。然后将新节点加入到节点集合中。

3. 重复步骤 2，直到只剩下一个节点为止，构造完成。

#### 应用

哈夫曼树广泛应用于*文件压缩*和*有效的数据传输*

1. 将每个待编码的符号作为一个叶结点，其权值为该符号的频度（或权重）
2. 构建哈夫曼树，将两棵具有最小权值的树合并成一棵新树
3. 重复步骤 2，直到只剩下一棵树为止
4. 根据哈夫曼树构建编码表，左子树分配 "0"，右子树分配 "1"

![哈夫曼编码示例](images/Pasted%20image%2020240913203345.png)
