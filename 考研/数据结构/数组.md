## 数组的基本概念

### 一维数组

### 二维数组

#### 二维数组的存储方式

二维数组可以按照行优先或列优先的方式进行存储

- **按照行优先存储**: 对于 M 行 N 列的二维数组 `b[M][N]`，若按行优先存储，则 `b[i][j]` 的存储地址可以通过以下公式计算:

    ```cpp
    LOC + (i*N + j) * sizeof(ElemType)
    ```

  其中，`LOC` 是二维数组的起始地址，即 `b[0][0]` 的地址

- **按照列优先存储**: 对于 M 行 N 列的二维数组 `b[M][N]`，若按列优先存储，则 `b[i][j]` 的存储地址可以通过以下公式计算:

    ```cpp
    LOC + ( j*M+ i )* sizeof(ElemType)
    ```

    其中，`LOC` 是二维数组的起始地址，即 `b[0][0]` 的地址

## 一些特殊的矩阵

### 对称矩阵

对于一个 n 阶方阵，如果任意一个元素 a[i,j] 都满足 a[i,j] = a[j,i]，则该矩阵为对称矩阵 (i，j 从 1 开始)

$$
\left[
\begin{matrix}
a_{1,1} & a_{1,2} & \cdots & a_{1,n} \\
a_{2,1} & a_{2,2} & \cdots & a_{2,n} \\
\vdots & \vdots & \ddots & \vdots \\
a_{n,1} & a_{n,2} & \cdots & a_{n,n}
\end{matrix}
\right]
$$

- 普通存储 $n*n$ 二维数组
- 压缩存储
  - 只存储主对角线 + 下三角区 (或主对角线 + 上三角区)

- 行优先  且只存主对角线 + 下三角区
- 数组大小 $(1+n)*n/2$

> [!NOTE] 站在程序员的角度，对称矩阵压缩存储后怎样才能方便使用？
> 可以实现一个 " 映射 " 函数
> 矩阵下标 -->一维数组下标:
>
> $$a[i, j] --> B[k]  (i≥j)$$

- 按行优先的原则，$a[i,j]$ 是第几个元素？

对于一个对称矩阵，我们只需要存储主对角线及其下三角区的元素。按照行优先的原则，我们可以通过一个映射函数将二维矩阵的元素索引 `a[i,j]` 映射到一维数组的索引 `B[k]`

$$k =
\begin{cases}
    \frac{i \times (i-1)}{2} + j - 1, & \text{if } i \geq j (主对角线及下三角区域)\\
    \frac{j \times (j-1)}{2} + i - 1, & \text{if } i < j (上三角区域)
\end{cases}$$

### 三角矩阵

- 上三角矩阵
    $$
    \left[
    \begin{matrix}
    a_{1,1} & a_{1,2} & \cdots & a_{1,n} \\
    & a_{2,2} & \cdots & a_{2,n} \\
    & & \ddots & \vdots \\
    & & & a_{n,n}
    \end{matrix}
    \right]
    $$
    $$
    k =
    \begin{cases}
    \frac{(i-1)(2n - i + 2)}{2} + j - i &, \qquad i \leq j \\
    \frac{n(n+1)}{2} &, \qquad i > j
    \end{cases}
    $$

- 下三角矩阵
    $$
    \left[
    \begin{matrix}
    a_{1,1} \\
    a_{2,1} & a_{2,2} \\
    \vdots & \vdots & \ddots \\
    a_{n,1} & a_{n,2} & \cdots a_{n,n}
    \end{matrix}
    \right]
    $$
    $$
    k =
    \begin{cases}
    \frac{i(i-1)}{2} + j - 1 &, \qquad i \geq j \\
    \frac{n(n-1)}{2} &, \qquad i < j
    \end{cases}
    $$

### 设 $n \times n$ 列矩阵下标从 1 开始，数组下标从 0 开始。矩阵元素 $i$ 和数组元素 $k$ 的对应关系为：

1. **压缩存储下三角区域 + 主对角线，行优先存储**

 $$

 k =
 \begin{cases}
 \frac{i(i-1)}{2} + j - 1, & i \geq j \quad (\text{下三角区域和主对角线元素}) \\
 \frac{j(j-1)}{2} + i - 1, & i < j \quad (\text{上三角区})
 \end{cases}

 $$

2. **压缩存储下三角区域 + 主对角线，列优先存储**

 $$

 k =
 \begin{cases}
 \frac{(j-1)(2n-j+2)}{2} + (i - j), & i \geq j \quad (\text{下三角区域和主对角线元素}) \\
 \frac{(i-1)(2n-i+2)}{2} + (j - i), & i < j \quad (\text{上三角区})
 \end{cases}

 $$

3. **压缩存储上三角区域 + 主对角线，行优先存储**

 $$

 k =
 \begin{cases}
 \frac{i(i-1)}{2} + (i - j), & i \leq j \quad (\text{上三角区域和主对角线元素}) \\
 \frac{j(j-1)}{2} + (j - i), & i > j \quad (\text{下三角区})
 \end{cases}

 $$

4. **压缩存储上三角区域 + 主对角线，列优先存储**

 $$

 k =
 \begin{cases}
 \frac{j(j-1)}{2} + i - 1, & i \leq j \quad (\text{上三角区}) \\
 \frac{i(i-1)}{2} + j - 1, & i > j \quad (\text{下三角区})
 \end{cases}

 $$
### 三对角矩阵(带状矩阵)

- 压缩存储策略
  按行优先(或列优先)原则，只存储带状部分

- $B[k]$得到$a[i,j]$的值

$$

\left[
\begin{matrix}
a_{1,1} & a_{1,2} \\
a_{2,1} & a_{2,2} & a_{2,3} & & 0 \\
& a_{3,2} & a_{3,3} & a_{3,4} \\
& & \ddots & \ddots & \ddots \\
& 0 & & a_{n-1,n-2} & a_{n-1,n-1} & a_{n-1,n} \\
& & & & a_{n,n-1} & a_{n, n}
\end{matrix}
\right]

$$

### 稀疏矩阵 非零元素远远少于矩阵元素的个数

$$

M =
\left[
\begin{matrix}
4 & 0 & 0 & 0 \\
0 & 0 & 6 & 0 \\
0 & 9 & 0 & 0 \\
0 & 23 &0 & 0
\end{matrix}
\right]

$$
- 顺序存储 —— 三元组<行，列，值>

$$

\left(
\begin{matrix}
i & j & a_{i,j} \\
0 & 0 & 4 \\
1 & 2 & 6 \\
2 & 1 & 9 \\
3 & 1 & 23
\end{matrix}
\right)

$$
- 链式存储 —— 十字链表法
## 数组的优点

- 数组存储在连续的内存空间内，且元素类型相同。这种做法包含丰富的先验信息，系统可以利用这些信息来优化数据结构的操作效率

- 空间效率高:数组为数据分配了连续的内存块，无须额外的结构开销
- 支持随机访问:数组允许在$O(1)$时间内访问任何元素
- 缓存局部性:当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度

### 缺点

连续空间存储是一把双刃剑，其存在以下局限性

- 插入与删除效率低:当数组中元素较多时，插入与删除操作需要移动大量的元素
- 长度不可变:数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大
- 空间浪费:如果数组分配的大小超过实际所需，那么多余的空间就被浪费了

### 数组的应用

- **随机访问**:如果我们想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样
- **排序和搜索**:数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行
- **查找表**:当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置
- **机器学习**:神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构
- **数据结构实现**:数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组

### 总结

## 矩阵压缩
*压缩存储*：指为多个值相同的元素只分配一个存储空间，对零元素不分配空间

*特殊矩阵*：指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布具有一定规律性的矩阵

*特殊矩阵的压缩存储*：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中

## 串

**串**：由零个或多个字符组成的有限序列称为字符串，简称串 (string)。例如，"hello" 和 "abc123" 都是串。

**空串**：零个字符的串称为空串，记为 $\varepsilon$。

**子串**：由一个串中任意个连续字符组成的子序列称为该串的子串 (substring)。例如，bcd 是 abcdefg 的子串。

abc 所有子串构成的集合为 $\{\varepsilon, a, b, c, ab, bc, abc\}$。

**前缀**：若对于某个串 $y$ 有 $x = wy$，则称串 $w$ 是串 $x$ 的前缀 (prefix)。  
若 $w$ 是 $x$ 的前缀且 $|w| < |x|$，则称串 $w$ 是串 $x$ 的真前缀 (proper prefix)。  
例如，abc 是 abcdefg 的真前缀。

**后缀**：若对于某个串 $y$ 有 $x = yw$，则称串 $w$ 是串 $x$ 的后缀 (suffix)。  
若 $w$ 是 $x$ 的后缀且 $|w| < |x|$，则称串 $w$ 是串 $x$ 的真后缀 (proper suffix)。  
例如，efg 是 abcdefg 的真后缀。

> **注意**：空串是任意一个串的前缀和后缀。

abc 所有前缀构成的集合为 $\{\varepsilon, a, ab, abc\}$。  
abc 所有真前缀构成的集合为 $\{\varepsilon, a, ab\}$。  
abc 所有后缀构成的集合为 $\{\varepsilon, c, bc, abc\}$。  
abc 所有真后缀构成的集合为 $\{\varepsilon, c, bc\}$。
### KMP算法

> [!NOTE] **KMP算法平均时间复杂度:O(n+m)**

https://www.bilibili.com/video/BV19C4y157dH/
![](images/1728358080280%201.jpg)

### `next` 数组简介

`next` 数组是 **KMP**（Knuth-Morris-Pratt）字符串匹配算法中用来优化匹配速度的辅助数组。该数组记录了模式串中每个位置之前的部分字符串的 **最长公共前后缀** 的信息，用于减少匹配失败时的回退量。

### 示例

对于给定的字符串，它们的 `next` 数组如下：

- `"abaab"` 的 `next` 数组为： `? 0 1 1 2 3`
- `"abaabc"` 的 `next` 数组为： `? 0 1 1 2 2 3`
- `"google"` 的 `next` 数组为： `? 0 1 1 2 1`
- `"ababaa"` 的 `next` 数组为： `? 0 1 1 2 3 4`

### 如何生成 `next` 数组

生成 `next` 数组的核心思想是：**找到每个位置的最长公共前后缀的长度**。算法流程如下：

1. **初始化**：
   - `next[0]` 通常设置为 `-1` 或 `0`，表示没有有效的前缀。
   - 变量 `j` 指向当前处理的字符，`k` 用来表示当前最长前缀的末尾位置。

2. **循环处理**：
   - 从模式串的第二个字符（即 `j=1`）开始，依次填充 `next` 数组的每个位置。
   - 如果模式串的当前字符与前缀能够继续匹配，则 `k++`，并将 `next[j] = k`。
   - 如果不能匹配，则回退到 `next[k]` 继续检查，直到找到匹配或者退回到初始状态。

3. **结束条件**：
   - 当模式串所有字符都处理完毕时，`next` 数组的构造结束。

### `next` 数组计算步骤

假设我们要为字符串 `"ababaa"` 计算 `next` 数组：

- 初始值：`next[0] = -1`
- `next[1] = 0`（"a" 无前后缀）
- `next[2] = 1`（"ab" 的最长公共前后缀为 "a"）
- `next[3] = 1`（"aba" 的最长公共前后缀为 "a"）
- `next[4] = 2`（"abab" 的最长公共前后缀为 "ab"）
- `next[5] = 3`（"ababa" 的最长公共前后缀为 "aba"）
- `next[6] = 4`（"ababaa" 的最长公共前后缀为 "abaa"）

最后得到 `next` 数组为：`[-1, 0, 1, 1, 2, 3, 4]`。

### `nextval` 数组优化

`nextval` 数组是对 `next` 数组的一种优化。其目的在于：**减少不必要的字符比较**。当 `next[j]` 指向的字符与模式串当前字符相同时，通常不需要回退太多，可以直接跳到 `next[next[j]]`，从而减少字符比较的次数。

#### `nextval` 数组生成规则：

- 如果 `P[next[j]] == P[j]`，那么设置 `nextval[j] = nextval[next[j]]`，直接跳过重复的部分。
- 否则，`nextval[j] = next[j]`。

### 优化示例

例如，对于模式串 `"abaabc"`，其 `nextval` 数组为：

- `nextval[0] = -1`
- `nextval[1] = 0`
- `nextval[2] = 1`
- `nextval[3] = 1`
- `nextval[4] = 2`
- `nextval[5] = 2`
- `nextval[6] = 3`

这使得在一些特定情况下，字符比较的次数会减少，从而提升匹配效率。
