## 常考点

  1. 存储数据时，不仅要存储数据元素的值，还要存储数据元素之间的关系
  2. 数据的逻辑结构独立于其存储结构
  3. 循环队列基于顺序存储，是一种具体的数据结构
  4. 栈/队列是一种抽象数据类型，可采用顺序存储或链式存储，只表示逻辑结构
  5. 有序表只表示逻辑结构
  6. 顺序表，哈希表，单链表既描述逻辑结构，又描述存储结构和数据运算
  7. 可以用抽象数据类型定义一个完整的数据结构 ADT

## 数据结构的基本概念和术语

| 术语   | 定义                                                                                                             |
| ---- | -------------------------------------------------------------------------------------------------------------- |
| 数据   | 信息的载体                                                                                                          |
| 数据元素 | 数据的基本单位                                                                                                        |
| 数据对象 | 具有相同性质的数据元素的集合，是数据的一个子集                                                                                        |
| 数据类型 | 一个值的集合和定义在此集合上的一系列操作的总称<br>**原子类型**: 其值不可再分的数据类型<br>**结构类型**: 其值可以再分解为若干成分的数据类型<br>**抽象数据类型**: 抽象数据组织及与之相关的操作<br> |
| 数据结构 | 相互之间存在一种或多种特定关系的数据元素的集合，包括数据和数据元素之间的关系                                                                         |

## 数据结构的三要素

### 逻辑结构

![](images/Pasted%20image%2020240912192847.png)

- 数据元素之间的逻辑关系，即从逻辑关系上描述数据
- 它与数据的存储无关，是独立于计算机的
- 逻辑结构主要分为线性结构（线性表、栈、队列）和非线性结构（图、树、集合）

> 常见的逻辑结构

| 数据元素的关系 | 例子 |
| --- | --- |
| 集合 | 同属于一个集合 |
| 线性结构 | 一对一 |
| 树形结构 | 一对多 |
| 图状结构或网状结构 | 多对多 |

### 物理结构

- 数据结构在计算机中的表示（又称映像），也称存储结构
- 包括数据元素的表示和关系的表示
- 它是用计算机语言实现的逻辑结构，依赖于计算机语言
- 主要的存储结构有：
  - **顺序存储**: 按顺序
  - **链式存储**：借助指示元素存储地址的指针
  - **索引存储**：建立附加的索引表
  - **散列存储**：根据元素的关键字直接计算出元素的存储地址，也叫哈希存储

| 存储<br/>结构 | 优点                             | 缺点                                                                              |
| --------- | ------------------------------ | ------------------------------------------------------------------------------- |
| 顺序<br/>存储 | 可以实现**随机存取**<br/>每个元素占用很少的存储空间 | 只能使用相邻的一整块存储单元<br/>可能产生较多的外部碎片                                                  |
| 链式<br/>存储 | **不会出现碎片现象**<br/> 能充分使用所有存储单元  | 每个元素因存储指针而占用额外的存储空间<br/> 只能实现顺序存取<br/> **不同节点的存储空间可以不连续**<br/> **同一节点的存储空间要连续** |
| 索引<br/>存储 | 检索速度快                          | 附加的索引表要占用存储空间<br/> 增加和删除数据时要修改索引表                                               |
| 散列<br/>存储 | 检索、增加和删除节点的操作很快                | 若散列函数不好，则可能出现元素存储单元的冲突<br>解决冲突又会增加时空开销                                          |

### 数据的运算

- 包括运算的定义和实现
- 运算的定义是针对逻辑结构的，指出运算的功能
- 运算的实现是针对存储结构的，指出运算的具体操作步骤

## 算法与算法评价

### 算法的的基本概念

### 算法

算法: 对特定问题求解步骤的一种描述，是指令的有限序列，其中的每条指令都代表一个或多个操作

#### 5 个重要特性

- **有穷性**: 一个算法必须总在有限步骤操作后结束，每个步骤可在有限时间内完成
- **确定性**: 算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出
- **可行性**: 算法中的描述的操作都可以通过已经实现的基本运算执行有限次来实现
- **输入**: 一个算法有**零个**或多个输入，这些输入取自某个特定的对象的集合
- **输出**: 一个算法有一个或多个输出，这些输出是与输入有特定关系的量

#### 预期目标

- **正确性**: 算法应能正确解决问题
- **可读性**: 一帮助人们理解
- **健壮性**: 当输入非法数据时，算法能适当的作出反应或进行处理，而不会产生莫名其妙的输出结果
- **高效率与低存储的需求**: 效率指算法执行的时间，存储量需求指算法执行过程中所需要的最大存储空间，两者都与瓦恩替的规模有关

### 时间复杂度

#### 概念

- 算法中基本语句重复执行的次数
- 是问题规模 n 的某个函数 f(n)
- 算法的时间度量记作:T$(n) = O( f(n) )$
- 基本语句: 执行次数最多、重复执行次数与算法执行时间成正比的语句

#### 分类

- 最好时间复杂度
- 平均时间复杂度: 所有可能输入实例在等概率条件下，算法的期望运行时间
  - **随机算法的时间复杂度一般是算期望并不是最坏的时间复杂度**
- 最坏时间复杂度: 默认情况下算这个

#### 计算

##### 定义法

##### Master 定理 (递归)

- 所有子问题规模相同的递归才能用 Master 公式，$T(n) = a \cdot T\left(\frac{n}{b}\right) + O(n^c)$，a、b、c 都是常数;

- 如果 $log_b a < c$，复杂度为:$O(n^c)$;

- 如果 $log_b a > c$，复杂度为:$O(n^{\log_b a})$;

- 如果 $\log_b a = c$，复杂度为:$O(n^c \log n)$;

- 🌟$T(n) = 2 \cdot T\left(\frac{n}{2}\right) + O(n \log n)$，时间复杂度是 $O(n (\log^2 n))$

#### 常对幂指阶

$$O(1) < O(log_2{n}) < O(n) < O(nlog_2{n}) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)$$

#### 常见的时间复杂度

##### 常数阶 $O(1)$

- 常数阶常见于数量与输入数据大小 n 无关的常量、变量、对象
- 需要注意的是，在循环中初始化变量或调用函数而占用的内存，在进入下一循环后就会被释放，因此不会累积占用空间，空间复杂度仍为 O(1)

```cpp
/* 常数阶 */
void constant(int n) {
    // 常量、变量、对象占用 O(1) 空间
    const int a = 0;
    int b = 0;
    int nums[1000];
    ListNode *node = newListNode(0);
    free(node);
    // 循环中的变量占用 O(1) 空间
    for (int i = 0; i < n; i++) {
        int c = 0;
    }
    // 循环中的函数占用 O(1) 空间
    for (int i = 0; i < n; i++) {
        func();
    }
}
```

##### 对数阶 $O(logn)$

- 与指数阶相反，对数阶反映了 " 每轮缩减到一半 " 的情况。设输入数据大小为 n ，由于每轮缩减到一半，因此循环次数是 $O(logn)$，即 $O(2^n)$ 的反函数;

```cpp
/* 对数阶(循环实现) */
int logarithmic(int n) {
    int count = 0;
    while (n > 1) {
        n = n / 2;
        count++;
    }
    return count;
}
```

> 分析:$第 k 次循环，n = \frac{n}{2^k}，当 n = 1时，循环结束，k = logn$

- 对数阶也常出现于递归函数中。比如形成了一棵高度为 log2⁡n 的递归树

```cpp
int logRecur(int n) {
    if (n <= 1)
        return 0;
    return logRecur(n / 2) + 1;
}
```

> 分析:
> $对于递归程序的时间复杂度 = 递归执行次数 \times 每次递归的时间复杂度$
> $从 n 开始 第 i 次递归 n = \frac{n}{2^i}，当 n = 1时，递归结束，i = logn$
> $每次递归的时间复杂度 = O(1)$
> $时间复杂度 = logn \times O(1) = O(logn)$

- 对数阶常出现于基于分治策略的算法中，体现了 " 一分为多 " 和 " 化繁为简 " 的算法思想。它增长缓慢，是仅次于常数阶的理想的时间复杂度

##### 线性阶 $O(n)$

- 线性阶常见于元素数量与 n 成正比的数组、链表、栈、队列等

```cpp
/* 线性阶(递归实现) 2012 真题*/
int fact(int n) {
    if (n < 1) return 1;
    return n * fact(n - 1);
}
```

> 分析:
> $从 n 开始 第 i 次递归 n = n - i，当 n = 1时，递归结束，i = n$
> $每次递归的时间复杂度 = O(1)$
> $时间复杂度 = n \times O(1) = O(n)$

```cpp
// Kadane 算法实现
int kadane(int A[], int n) {
    // 初始化最大和和当前和为0
    int maxSum = 0, thisSum = 0;
    // 遍历数组
    for (int i = 0; i < n; i++) {
        // 将当前元素加到当前和上
        thisSum += A[i];
        // 如果当前和大于最大和，则更新最大和
        if (thisSum > maxSum) {
            maxSum = thisSum;
        } 
        // 如果当前和小于0，则重置当前和为0
        else if (thisSum < 0) {
            thisSum = 0;
        }
    }
    // 返回最大和
    return maxSum;
}

```

> 分析:
> $遍历数组，时间复杂度 = O(n)$

##### 线性对数阶 $O(nlogn)$

```cpp
/* 线性对数阶 */
int linearLogRecur(int n) {
    if (n <= 1)
        return 1;
    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);
    for (int i = 0; i < n; i++) {
        count++;
    }
    return count;
}
```

> 分析:
> $从 n 开始 第 i 次递归 n = \frac{n}{2^i}，当 n = 1时，递归结束，i = logn$
> $每次递归的时间复杂度 = O(n)$
> $时间复杂度 = logn \times O(n) = O(nlogn)$

```cpp
// 计算跨越中点的最大子序列和
int maxCrossingSum(int A[], int l, int m, int h) {
    int sum = 0;
    int left_sum = INT_MIN;
    // 计算中点到左边界的最大子序列和
    for (int i = m; i >= l; i--) {
        sum += A[i];
        if (sum > left_sum) {
            left_sum = sum;
        }
    }

    sum = 0;
    int right_sum = INT_MIN;
    // 计算中点到右边界的最大子序列和
    for (int i = m + 1; i <= h; i++) {
        sum += A[i];
        if (sum > right_sum) {
            right_sum = sum;
        }
    }

    // 返回跨越中点的最大子序列和
    return left_sum + right_sum;
}

// 计算最大子序列和
int maxSubArraySum(int A[], int l, int h) {
    // 如果数组只有一个元素，返回该元素
    if (l == h) {
        return A[0];
    }

    // 找出数组的中点
    int m = (l + h) / 2;
    // 返回三者中的最大值:左半部分的最大子序列和，右半部分的最大子序列和，以及跨越中点的最大子序列和
    return max(max(maxSubArraySum(A, l, m), maxSubArraySum(A, m + 1, h)),
               maxCrossingSum(A, l, m, h));
}
```

> 分析:
> $递归树的高度为 logn$
> $每次递归的时间复杂度 = O(n)$
> $时间复杂度 = logn \times O(n) = O(nlogn)$

```cpp
for (int i = 1; i <= N; i++) {
    for (int j = i; j <= N; j += i) {
        // 这两个嵌套for循环的流程，时间复杂度为O(N * logN)
        // 1/1+ 1/2 + 1/3 + 1/4 + 1/5 + ... + 1/n，也叫"调和级数"，收敛于O(logN)
        // 所以如果一个流程的表达式 : n/1+ n/2 + n/3 + ... + n/n
        // 那么这个流程时间复杂度O(N * logN)
    }
}
```

- 调和级数

##### 平方阶 $O(n^2)$

```cpp
/* 平方阶 */
int quadratic(int n) {
    int count = 0;
    // 循环次数与数据大小 n 成平方关系
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            count++;
        }
    }
    return count;
}
```

> 分析:
> $嵌套循环，外层循环 n 次，内层循环 n 次，总共执行 n^2 次$

```cpp
int maxSubsequenceSum(const int A[], int N) {
    int MaxSum = 0;
    for (int i = 0; i < N; i++) {
        for (int j = i; j < N; j++) {
            int ThisSum = 0;
            for (int k = i; k <= j; k++) {
                ThisSum += A[k];
            }
            if (ThisSum > MaxSum) {
                MaxSum = ThisSum;
            }
        }
    }
    return MaxSum;
}

```

> 分析:
> $嵌套循环，第一层循环 从 0 到 N - 1，第二层循环 从 i 到 N - 1，第三层循环 从 i 到 j$
> $时间复杂度 = O(n^3)$

```cpp
int maxSubsequenceSum(const int A[], int N) {
    int maxSum = 0;
    for (int i = 0; i < N; i++) {
        int thisSum = 0;
        for (int j = i; j < N; j++) {
            thisSum += A[j];
            if (thisSum > maxSum) {
                maxSum = thisSum;
            }
        }
    }
    return MaxSum;
}

```

> 分析:
> $嵌套循环，第一层循环 从 0 到 N - 1，第二层循环 从 i 到 N - 1$
> $时间复杂度 = O(n^2)$

```cpp
void bubbleSort(std::vector<int>& arr) {
    if (arr.empty() || arr.size() < 2) {
        return;
    }

    int n = arr.size();
    int end = n - 1, i = 0;

    while (end > 0) {
        if (arr[i] > arr[i + 1]) {
            swap(arr, i, i + 1);
        }
        if (i < end - 1) {
            i++;
        } else {
            end--;
            i = 0;
        }
    }
}
```

- 冒泡排序时间复杂度为 $O(n^2)$

##### 指数阶 $O(2^n)$

- 指数阶常出现于递归函数中。例如在以下代码中，其递归地一分为二，经过 n 次分裂后停止

##### 阶乘阶 $O(n!)$

- 阶乘阶对应数学上的 " 全排列 " 问题。给定 n 个互不重复的元素，求其所有可能的排列方案，方案数量为:

```cpp
/* 阶乘阶(递归实现) */
int factorialRecur(int n) {
    if (n == 0)
        return 1;
    int count = 0;
    for (int i = 0; i < n; i++) {
        count += factorialRecur(n - 1);
    }
    return count;
}
```

> 分析:
> $从 n 开始 第 i 次递归 n = n - i，当 n = 0 时，递归结束，i = n$
> $每次递归的时间复杂度 = O(n)$
> $时间复杂度 = n \times O(n) = O(n!)$

### 空间复杂度

- 算法所需存储空间的度量:S(n) = O( f(n) )
- 算法本身要占据的空间 + 辅助空间 (算这个，注意递归深度也是)
- 算法原地工作: 算法所需的辅助空间为常量，O(1)

## 时间复杂度真题

### 2001

```cpp
x = 2
while (x < n / 2) 
    x = 2 * x
```

> 分析:
> $第 k 次循环，x = 2^k，当 x = n 时，循环结束，k = logn$
> $每次循环的时间复杂度 = O(1)$
> $时间复杂度 = logn \times O(1) = O(logn)$

### 2012

```cpp
int fact(int n) {
	if (n <= 1)
		return 1;
	return n * fact(n - 1);
}
```

$$
O(n)
$$

### 2014

```cpp
count = 0;
for (k = 1; k <= n; k *= 2) 
    for (j = 1; j <= n; j++) 
        count++;
```

$$
\sum_{k=1}^{[\log_2{n}]} \sum_{j=1}^{n} 1= n \log_2{n}
$$

### 2017

```cpp
int func(int n) {
	int i = 0, sum = 0;
	while (sum < n)
		sum += ++i;
	return i;
}
```

$$
\frac{k(k+1)}{2} \leq n => k^2 + k - 2n \leq 0 => k = \frac{-1 + \sqrt{1+8n}}{2} => O(\sqrt{n})
$$

### 2022 时间复杂度:$O(n)$

```cpp
int sum = 0;
for (int i = 1; i < n; i *= 2) 
    for (int j = 0; j < i; j++) 
        sum++;
```

$$
\sum_{i=1}^{[\log_2{n}]} \sum_{j=0}^{2^i-1} 1 = n - 1
$$
