## 队列的定义

- **是一种操作受限的线性表，只允许在表的一端进行插入 (队尾)，另一端进行删除 (队头)**
- 队头 (front): 删除元素的一端
- 队尾 (rear): 插入元素的一端
- 特点
  - **先进先出 (FIFO)**
  - 给定一个入队序列 $<a_1，a_2，a_3，…，a_n>$，可以得到 1 种出队序列，即 $<a_1，a_2，a_3，…，a_n>$;
  - 一致性: 出队序列与入队序列一致;
  - 唯一性: 出队序列唯一;
  - 单调性: 出队序列的元素下标序列为单调递增序列;

## 队列的基本操作

|操作 | 描述|
|--- | ---|
|InitQueue(&Q) | **初始化队列**，构造一个空队列 Q|
|DestroyQueue(&Q)| **销毁队列**，销毁并释放队列 Q 所占用的内存空间|
|EnQueue(&Q, x)| **入队**，若队列 Q 未满，将 x 加入，使之成为新的队尾|
|DeQueue(&Q,&x)| **出队**，若队列 Q 非空，删除队头元素，并用 x 返回|
|GetHead(Q,&x)| **读队头元素**，若队列 Q 非空，则将队头元素赋值给 x|
|QueueEmpty(Q)| **判空操作**，判断队列是否为空|

![](images/Pasted%20image%2020240913204912.png)

## 顺序队列

分配一块连续的存储单元存放队列中的元素设置两个指针：

- 队头指针 `front` 指向队头元素
- 队尾指针 `rear` 指向队尾元素的下一个位置

```cpp
#define MaxSize 50
typedef struct
{
    ElemType data[MaxSize];
    int front, rear;
} SqQueue;
```

| 操作       | 说明                                                         |
|--|--|
| 初始状态   | Q.front = Q.rear = 0|
| 队满操作   | Q.rear == MaxSize 不能作为队列满的条件<br/>只有一个元素仍满足该条件（假溢出）|
| 队空操作   | Q.front == Q.rear|
| 队列长度   | Q.rear - Q.front|
| 入队操作   | 队不满时，**先送值到队尾元素，再将队尾指针加 1**|
| 出队操作   | 队不空时，**先取队头元素值，再将队头指针加 1**|

## 循环队列

> [!NOTE]
> 把存储队列元素的表 **从逻辑上视为一个环**

### 队空队满判断

![](images/Pasted%20image%2020240913204933.png)
![](images/Pasted%20image%2020241008120456.png)

### 代码

- 初始状态

```cpp
Q.front = Q.rear = 0;
```

- 判队空

```cpp
return Q.rear == Q.front;
```

- 判队满

```cpp
return (Q.rear + 1) % MaxSize == Q.front;
```

- 入队

```cpp
if ((Q.rear + 1) % MaxSize == Q.front)
    return ;
Q.data[Q.rear] = x;
Q.rear = (Q.rear + 1) % MaxSize;
```

- 出队

```cpp
if (Q.rear == Q.front)
    return ;
x = Q.data[Q.front];
Q.front = (Q.front + 1) % MaxSize;
```

## 链式队列

![](images/Pasted%20image%2020240913204945.png)

### 链式队列的定义

- 实质上是一个同时带有队头指针和队尾指针的单链表
- **头指针指向队头节点，尾指针指向队尾节点，即单链表的最后一个节点**
- 删除操作时，通常仅需要修改头指针
- 当队列只有一个元素时，队列为空，修改尾指针为 read=front

### 链式队列的实现

```cpp
// 定义链式队列节点的结构体
typedef struct LinkNode {
    ElemType data; // 节点存储的数据
    struct LinkNode *next; // 指向下一个节点的指针
} LinkNode;

// 定义链式队列的结构体
typedef struct {
    LinkNode *front; // 指向队列头部的指针
    LinkNode *rear; // 指向队列尾部的指针
} LinkQueue;
```

```cpp
// 初始化队列
void InitQueue(LinkQueue &Q) {
    // 为队列头尾节点分配内存，并使它们指向同一个节点
    Q.front = Q.rear = (LinkNode *)malloc(sizeof(LinkNode));
    if (!Q.front) exit(1); // 如果内存分配失败，则退出程序
    Q.front->next = NULL; // 初始化队列为空
}

// 判断队列是否为空
bool isEmpty(LinkQueue Q) {
    return Q.rear == Q.front; // 如果头尾指针相等，则队列为空
}

// 入队操作
bool EnQueue(LinkQueue &Q, ElemType x) {
    LinkNode *s = (LinkNode *)malloc(sizeof(LinkNode)); // 为新节点分配内存
    if (!s) exit(1); // 如果内存分配失败，则退出程序
    s->data = x; // 设置新节点的数据
    s->next = NULL; // 新节点的下一个节点为空
    Q.rear->next = s; // 将新节点插入到队尾
    Q.rear = s; // 更新队尾指针
    return true;
}
// 出队操作
bool DeQueue(LinkQueue &Q, ElemType &x) {
    if (Q.rear == Q.front) return false; // 如果队列为空，则出队失败
    LinkNode *p = Q.front->next; // 获取队头节点的下一个节点
    x = p->data; // 获取队头节点的数据
    Q.front->next = p->next; // 修改队头节点的指针
    if (Q.rear == p) Q.rear = Q.front; // 如果队列中只有一个节点，则修改队尾指针
    free(p); // 释放队头节点的内存
    return true;
}
```

## 🌟🌟🌟循环队列

将顺序表空间想象为一个首尾相接的圆环，存储在其中的队列称为循环队列 (circular queue)

循环队列中区分队列空和队列满，有三种处理方式：

1. **空一法**: 预留一个单元来区分队列空和队列满，入队时少用一个队列单元，这是一个较为普遍的做法
2. **计数法**: 类型中设置表示元素个数的变量成成员 size
3. **标记法**: 类型中设置用区分队列空或满的变量成员 tag，入队标记 tag = 1，出队标记 tag = 0
![](./images/Pasted%20image%2020241018085638.png)

### 真题考点

由于头尾指针区分类型的不同和循环队列中区分队列空和队列满的不同，根据混法原则，总共有 $4 \times 3 = 12$ 种循环队列的建法

这里需要注意闭区间型和左闭右开队尾指针在入队操作的区别:

- 队尾指针指向队尾元素位置:
  - **入队**时，先将队尾指针先往后移动一个位置，再放入元素;
- 队尾指针指向队尾元素位置下一个位置:
  - **入队**时，先放入元素，再将队尾指针先往后移动一个位置;

## 🌟🌟🌟输入受限的双端队列和输出受限的双端队列

> 例题: 设有一个双端队列，元素进入该队列的顺序是 1，2，3，4，试分别求出满足下列条件的输出序列

### 左边完全受限的双端队列 (右边完全受限的双端队列一样)

- 就相当于一个栈，栈底是左端，栈顶是右端，输出序列我们暂时记为 A1, A2, A3, A4;
- 最重要的结论来了，**当 Ai = N (i, N 为 1 到 4 的正整数)，比 Ai 先入栈的元素在输出序列中的顺序必须和入栈顺序相反，依次出栈**;
- 比如输出为 3，*，*，*；则后面三个未知序列中不允许出现 1 在 2 前面输出。因为以 3 开头说明 3 是第一个出栈的元素，而 1 只能在 2 出栈之后才有可能出栈
- 这个规律是顺延到后面的每一位，比如输出为 1。*，*，*。则后面三个数字剩余 2,3,4 这三个数，如果 4 在头，那后面两位只能是 3,2，不能是 2,3 这种 (好绕，不知道我有没有说清楚，没搞清楚的多读两遍，琢磨琢磨)

所以 **不可能的序列** 就有

| 序列 |
|:--:|
| 4，1，2，3 |
| 4，1，3，2 |
| 4，2，1，3 |
| 4，2，3，1|
| 4，3，1，2 |
| 3，1，2，4 |
| 3，1，4，2 |
| 3，4，1，2 |
| 2，4，1，3 |
| 1，4，2，3 |

总共有 10 种。则满足的序列为剩余的 4！- 10 = 14 种 $\frac{1}{5}C_{10}^5 = 14$

### 输入受限的双端队列 (队首在后端)

![](images/Pasted%20image%2020240924212105.png)
我们的队列入队还是只有一端入队，为 1,2,3,4；出队是可以两端任意出队;

我们在第一步的基础上只需要分析，第一种不能出队的那 10 种情况现在哪些可以了就行;

| 序列 | 结果 | 解释 |
| --- | --- | --- |
| 4，1，2，3 | √ | 完全入队之后左右间隔出队即可 |
| 4，1，3，2 | √ | 完全入队之后左右间隔出队即可 |
| 4，2，1，3 | × | 4 先出队，说明是等完全入队之后才开始出队，所以只能走 4 后面只能跟 1 或者 3 |
| 4，2，3，1| × | 4 先出队，说明是等完全入队之后才开始出队，所以只能走 4 后面只能跟 1 或者 3 |
| 4，3，1，2 | √ | 完全入队之后左右间隔出队即可 |
| 3，1，2，4 | √ | 完全入队之后左右间隔出队即可 |
| 3，1，4，2 | √ | 完全入队之后左右间隔出队即可 |
| 3，4，1，2 | √ | 完全入队之后左右间隔出队即可 |
| 2，4，1，3 | √ | 因为入队顺序是 1,2,3,4,；所以如果 2 是第一个出队，只能是从右边出队，<br/>而且是在 2 入队之后，3 入队之前这个时间点。|
| 1，4，2，3 | √ | 完全入队之后左右间隔出队即可 |

综上所述，输入受限的双端队列的可能的出队序列个数为 4！- 2 = 22

### 输出受限的双端队列

![](images/Pasted%20image%2020240924212126.png)

- 在这种队列中，两端 (头和尾) 是相邻的，并且位于队列的中间，而不是像常规队列那样，头部在一端，尾部在另一端;
- 前端相当于栈，后端相当于队列，就是头挨着的意思, **序列从中间分开，两边必须是向端方向单调递增。**
- 输出受限的双端队列的出队序列拆分为两个子序列: 出栈子序列和出队子序列。由于输出受限的双端队列只能从一端出队，所以更准确的说 **输出受限的双端队列的出队序列可以拆分出栈子数组和出队子数组**，且 **出栈子数组先于出队子数组在输出受限的双端队列中出队**

给定一个输出受限的双端队列的入队序列：<1, 2, 3, 4, 5, 6, 7, 8, 9, 10>

给定一个输出受限的双端队列的出队序列：<8, 6, 4, 2, 10, 1, 3, 5, 7, 9>

通过观察，很容易进行拆分：

输出受限的双端队列的入队序列：<<font color="#245bdb">1</font>,<font color="#ff0000"> 2</font>, <font color="#245bdb">3</font>,<font color="#ff0000"> 4</font>, <font color="#245bdb">5</font>, <font color="#ff0000">6</font>, <font color="#245bdb">7</font>, <font color="#ff0000">8</font>, <font color="#245bdb">9</font>, <font color="#ff0000">10</font>>

输出受限的双端队列的出队序列：<<font color="#ff0000">8</font>, <font color="#ff0000">6</font>, <font color="#ff0000">4</font>, <font color="#ff0000">2</font>, <font color="#ff0000">10</font>, <font color="#245bdb">1</font>, <font color="#245bdb">3</font>, <font color="#245bdb">5</font>, <font color="#245bdb">7</font>, <font color="#245bdb">9</font>>

首先，出栈子数组先于出队子数组在输出受限的双端队列中出队

然后，只需要验证出栈子数组 <<font color="#ff0000">8</font>, <font color="#ff0000">6</font>, <font color="#ff0000">4</font>,<font color="#ff0000"> 2</font>, <font color="#ff0000">10</font>>**能否通过入栈序列**<<font color="#ff0000">2</font>, <font color="#ff0000">4</font>, <font color="#ff0000">6</font>, <font color="#ff0000">8</font>, <font color="#ff0000">10</font>> 得到

与第二个输入受限的双端队列类似，我们输出受限的双端队列也建立在第一个左边完全受限的双端队列的基础上再进行分析;

| 序列      | 结果  | 解释                                                              |
| ------- | --- | --------------------------------------------------------------- |
| 4，1，2，3 | √   | 4 开头说明 4 和 1 分别是前后端的队首，假定 4 在前端队首<br/>而 1,2,3 依次从后端入队，则输出顺序正好满足 |
| 4，1，3，2 | ×   | 次序列要成立，4 必须入前端，3,2 可以入后端，</br>但是 1 就没地方入队了</br>所以此序列有误          |
| 4，2，1，3 | √   | $4 2 1\| 3$                                                     |
| 4，2，3，1 | ×   | ❌序列从中间分开，两边必须是向端方向单调递增                                          |
| 4，3，1，2 | √   | $4 3 \| 12$                                                     |
| 3，1，2，4 | √   | $3 \| 12\ \boxed{4}$                                            |
| 3，1，4，2 | √   | $3 1 \|\ \boxed{4}$ 2                                           |
| 3，4，1，2 | √   | $3\ \boxed{4}\  \| 12$                                          |
| 2，4，1，3 | √   | $2\ \boxed{4}\  \| 1\ \boxed{3}\ \ or \ \ \boxed{2}\  4 \| 13$  |
| 1，4，2，3 | √   | $\ \boxed{1}\  4 \| 2 3$                                        |

综上所述，输出受限的双端队列的可能的出队序列个数为 4！- 2 = 22

---

## 队列的应用

### 层次遍历

二叉树的层次遍历是一种广度优先搜索 (BFS) 的应用

### 数据缓存区

队列是实现数据缓冲区 (buffer) 的理想选择。在多种场景中，如操作系统的进程调度、银行排队、打印任务的排队等，数据必须等待在一个区域内直到资源准备好进行处理。队列可以确保数据按照它们到达的顺序被处理，从而维持数据处理的公平性和顺序性;

示例应用：打印队列

- 打印队列管理待打印的文档，确保每个文档按提交顺序进行打印。在多用户环境中，队列确保处理过程中不会发生冲突或重复;

### 任务调度

在多任务操作系统中，队列用于调度任务，特别是在 CPU 调度和 I/O 调度中。操作系统维护多个队列，每个队列对应一个特定优先级的任务集合，CPU 和 I/O 资源按队列分配给任务; 示例应用：操作系统的进程调度

- 操作系统使用队列来管理多个进程的执行顺序，根据进程的优先级和需求合理分配 CPU 时间片;
