### 宏观概述

- 这是一个**客户端和服务器之间的通信**，实现了端到端的请求和响应。
  - **浏览器进程** 与 **Web 服务器进程**之间通过多个协议层进行通信

 > 过程

#### 1. 客户端数据封装过程

![](./images/Pasted%20image%2020240907185544.png)

- **应用层**：创建 HTTP 请求报文（例如 GET 请求），然后将其交付给传输层
- **传输层**：传输层为 HTTP 请求报文添加 **TCP 首部**（包括源端口、目的端口等），形成 **TCP 报文段**，再交付给网络层
- **网络层**：为 TCP 报文段添加 **IP 首部**（包括源 IP 地址、目的 IP 地址等），形成 **IP 数据报**，交付给数据链路层
- **数据链路层**：为 IP 数据报添加 **帧首部和帧尾部**（如以太网帧），形成 **帧**，通过物理层传输
- **物理层**：将帧转换为 **比特流**，通过物理介质（如光纤、电缆等）发送出去

#### 2. 路由器数据转换

- **物理层**：路由器收到 **比特流**，将其重组为 **帧**，传递给数据链路层
- **数据链路层**：将 **帧** 还原为 **IP 数据报**，并传递给网络层
- **网络层**：
  - 路由器查找 **路由表**，根据目的 IP 地址决定数据的转发路径
  - 如果数据包需要转发到另一个网络，路由器会将 **IP 数据报**（不变）封装为新的 **帧**，并通过数据链路层传输

  > [! ] 路由器工作在网络层，它只处理 IP 数据报，不涉及传输层及以上的数据

- **数据链路层**：根据下一跳的物理地址，路由器将 **IP 数据报** 封装为新的 **帧**
- **物理层**：将 **帧** 转为 **比特流**，通过物理介质将其发送到下一跳路由器或目的服务器

##### NAT（网络地址转换）【私网 IP ➡️ 公网 IP】

- NAT 的作用: 隐藏私网地址，使多个设备通过单一公网 IP 访问外网。

当客户端位于私有网络中（使用私有 IP 地址）并发出 HTTP 请求时，这一请求首先通过本地网络传递到 **NAT 路由器**（家庭或企业网络中的网关设备）。此时，客户端的请求还包含私有 IP 地址

- **源 IP 地址转换**：当请求到达 NAT 路由器时，NAT 会将客户端的 **私有 IP 地址**（如 `192.168.1.2`）替换为路由器的 **公网 IP 地址**（如 `203.0.113.5`）
- **源端口号转换**：NAT 路由器还会为该请求分配新的 **源端口号**，用于区别同一公网 IP 上的多个私有网络设备的请求
- **记录 NAT 表**：NAT 路由器会创建 NAT 映射表，记录私有 IP 和公网 IP、端口号的对应关系

- NAT 路由器将修改后的数据包发送到公网，使用转换后的公网 IP 地址与目标 Web 服务器通信

- **服务器响应**：Web 服务器接收到请求后，生成 HTTP 响应报文，将响应发送到 NAT 路由器的公网 IP 地址和分配的端口号

> NAT 路由器的反向转换阶段

- **反向转换**：NAT 路由器接收到 Web 服务器的响应数据包后，使用 NAT 表将目标 IP 地址从 **公网 IP 地址**（`203.0.113.5`）转换回 **私有 IP 地址**（如 `192.168.1.2`）
- **端口号匹配**：路由器通过匹配 NAT 表中的端口号，找到对应的私网设备，并将数据包转发给该设备

#### 3. 服务器的数据转换

- **物理层**：服务器从物理介质中接收 **比特流**，并重新组合为 **帧**，交付给数据链路层
- **数据链路层**：将 **帧** 还原为 **IP 数据报**，交付给网络层
- **网络层**：将 **IP 数据报** 还原为 **TCP 报文段**，交付给传输层
- **传输层**：将 **TCP 报文段** 还原为 **HTTP 请求报文**，交付给应用层
- **应用层**：服务器在应用层处理请求报文（如读取 `index. html`），生成 **HTTP 响应报文**，再交付给传输层

#### 4. 服务器返回数据的过程

- **传输层**：为 **HTTP 响应报文** 添加 **TCP 首部**，形成 **TCP 报文段**，交付给网络层
- **网络层**：为 **TCP 报文段** 添加 **IP 首部**，形成 **IP 数据报**，交付给数据链路层
- **数据链路层**：将 **IP 数据报** 封装为 **帧**，并通过物理层发送出去
- **物理层**：将帧转换为 **比特流**，通过网络发送至客户端

#### 5. 客户端接收响应的过程

- **物理层**：将接收到的 **比特流** 转为 **帧**，交付数据链路层
- **数据链路层**：将 **帧** 转为 **IP 数据报**，交付网络层
- **网络层**：将 **IP 数据报** 还原为 **TCP 报文段**，交付传输层
- **传输层**：将 **TCP 报文段** 还原为 **HTTP 响应报文**，交付应用层（浏览器）
- **应用层**：浏览器解析 **HTTP 响应报文**，并渲染网页内容

### 细节

当点击超链接（如 [http://www. abc. com/index. html])，浏览器通过 **HTTP/1.1 默认的持久连接**来完成对页面的请求。这个过程可以分为以下几个步骤：

#### DNS 解析【域名 ➡️ IP 地址】

##### 用户主机高速缓存

用户主机会在本地缓存中查找域名对应的 IP 地址，如果找到则直接使用，否则进行 DNS 解析

##### DNS 查询请求报文【用户主机缓存没有命中】

- 浏览器向本地 DNS 服务器发送 DNS 查询请求报文，请求解析域名 [http://www. abc. com] 对应的 IP 地址
- 数据封装过程：DNS 报文 ➡️ UDP 报文 ➡️ UDP 数据报 ➡️ IP 数据报 ➡️ CSMA/CD ➡️ 以太网帧 ➡️ 电信网络

**封装 UDP 数据报头部**【传输层的 UDP 协议】：

- **应用层**：生成 **DNS 查询请求报文**，请求 `www. abc. com` 的 IP 地址
- **传输层**：将 DNS 查询请求报文封装为 **UDP 报文**，包括：
  - **源端口号**：随机分配的端口号
  - **目的端口号**：53（DNS 服务器的默认端口）
- **网络层**：将 UDP 报文封装为 **IP 数据报**，并填入源 IP 地址（用户主机）和目的 IP 地址（DNS 服务器）
- **数据链路层**：将 IP 数据报封装为 **以太网帧**，包含 MAC 地址信息，然后交给物理层

##### DNS 服务器解析查询报文并进行查询

- 解析出 UDP 数据报，UDP 数据报的目的端口为 53 端口，表明讲 UDP 用户数据报的载荷部分，也就是 DNS 查询请求报文，交付给 DNS 服务器端进程

- **递归查询**：用户主机的 DNS 客户端向本地域名服务器（由 ISP 提供）发送 **递归查询**，请求解析域名 `www. abc. com`
- **迭代查询**：本地域名服务器会使用 **迭代查询** 向根域名服务器、顶级域名服务器和权限域名服务器逐级查询：
    1. **根域名服务器**：返回 `. com` 顶级域名服务器的 IP 地址
    2. **顶级域名服务器**：返回 `abc. com` 权限域名服务器的 IP 地址
    3. **权限域名服务器**：返回 `www. abc. com` 的具体 IP 地址

DNS 服务器收到查询请求后，会通过这些步骤完成查询，并将最终结果返回给本地域名服务器

##### DNS 响应报文

DNS 服务器将查询到的 IP 地址封装在 DNS 响应报文中，返回给用户主机

**封装 UDP 数据报头部**：

- 源端口号：53（DNS 服务器的端口号）
- 目的端口号：随机端口号
- UDP 数据报封装在 IP 数据报中，通过以太网发送给用户主机

##### 用户主机收到 IP 地址

- 用户主机从 DNS 响应报文中解析出目标 IP 地址，并将其用于后续的 HTTP 请求

#### ARP【IP 地址 ➡️ MAC 地址】

> [! ] DNS 过程和 HTTP 访问过程均适用到

> [! ] OSPF 认为最小代价是好路由，ARP 不能跨网使用，只能逐个网络（链路使用）
>
> [[src/湖科大25每日一题#OSPF ARP|湖科大25每日一题]]

#### 判断是否在同一个网段

- 使用 **CIDR**（无类别域间路由）格式
- 通过 **IP 地址** 和 **子网掩码** 进行比较

##### 在同一个网段

> **查看 ARP 缓存**

- **有**对应的 MAC 地址：直接将 IP 数据报封装成帧进行传输
- **无**对应的 MAC 地址：发起 ARP 请求，步骤如下：
  - **ARP 请求广播**：通过广播发送 ARP 请求帧，目标地址为全 F (`FF:FF:FF:FF:FF:FF`)，此请求会在本地网络中进行广播
  - **单播 ARP 响应**：目标主机接收到 ARP 请求后，返回单播的 ARP 响应，提供它的 MAC 地址
  - **封装成帧**：获取到目标 MAC 地址后，将 IP 数据报封装成以太网帧，并通过物理层发送

##### 不在同一个网段

> **查看是否有默认网关**

- **没有默认网关**：如果没有配置默认网关，数据包将被丢弃，因为没有路径到达目的地
- **有默认网关**：如果有配置默认网关，数据包将通过网关传输，查看 ARP 缓存
  - **有**网关的 MAC 地址：直接将数据包封装成帧，发送到默认网关
  - **无**网关的 MAC 地址：发起 ARP 请求，步骤如下：
  - **ARP 请求广播**：向默认网关发送 ARP 请求帧，目标地址仍然是全 F，通过广播方式询问网关的 MAC 地址
  - **单播 ARP 响应**：网关收到请求后，返回单播的 ARP 响应，提供其 MAC 地址
  - **封装成帧**：获得网关的 MAC 地址后，将数据包封装成帧，并通过物理层发送到网关，进行跨网段传输

### HTTP 数据传输

1. **DNS 解析**：

   - **命中缓存**：如果浏览器、操作系统或本地 DNS 服务器已经缓存了目标 IP 地址，则解析速度会非常快，无需递归查询
   - **无缓存时的递归查询**：若没有缓存，解析过程会逐级查询根 DNS、顶级域名服务器（TLD）、权威 DNS 服务器等。每个步骤的查询通常需要一个 RTT​​

2. **建立 TCP 连接（三次握手的前两次）**：
     - TCP 连接的默认端口号为 `80`

   > 解析出 IP 地址后，浏览器与服务器之间通过 TCP 三次握手建立连接：
        1. 客户端发送 `SYN` 报文，表示请求连接
        2. 服务器收到请求后，回复 `SYN-ACK` 报文，表示同意连接
        3. 客户端接收到 `SYN-ACK` 后，回复 `ACK`，<span style="background:#affad 1">同时可以附带 HTTP 请求报文（如 GET 请求）来请求网页内容（HTML 文件）</span>
    - **时间消耗**：三次握手的时延为一个 RTT（往返时延）

3. **发送 HTTP 请求与获取响应**：

    - 在第三次握手时，浏览器发送 HTTP 请求，服务器接收到请求后，返回 HTTP 响应报文，通常包含 `index. html` 文件
    - 服务器会按照 TCP 的拥塞控制算法（慢启动、拥塞避免等）进行数据传输。在初始阶段，传输窗口的大小通常是 MSS（最大报文段大小），并逐步增大，传输每个窗口的数据需要一个 RTT
    - 发送窗口的大小与拥塞控制算法息息相关，传输速度会逐步提升直到达到带宽限制或发生丢包
4. **解析 HTML 并请求引用资源**：

    - 在第三次握手时，浏览器发送 HTTP 请求，服务器接收到请求后，返回 HTTP 响应报文，通常包含 `index. html` 文件
    - 服务器会按照 TCP 的拥塞控制算法（慢启动、拥塞避免等）进行数据传输。在初始阶段，传输窗口的大小通常是 MSS（最大报文段大小），并逐步增大，传输每个窗口的数据需要一个 RTT
    - 发送窗口的大小与拥塞控制算法息息相关，传输速度会逐步提升直到达到带宽限制或发生丢包

5. **释放 TCP 连接（四次挥手）**：

    - 当所有请求都处理完毕，浏览器和服务器之间会通过四次挥手关闭 TCP 连接：
        1. 客户端发送 `FIN` 报文，表示请求关闭连接
        2. 服务器收到后回复 `ACK`，表示同意
        3. 服务器发送 `FIN`，表示自己也准备关闭连接
        4. 客户端收到后回复 `ACK`，关闭连接
    - 关闭过程同样需要一个 RTT​​

### 做题思路

根据这个过程，点击超链接后会涉及到多个不同的延迟，这些延迟可以用 RTT 来表示：

1. **DNS 解析**：若没有缓存，递归查询会涉及多次 RTT，具体数量取决于查询的层级数。
2. **TCP 三次握手**：建立连接消耗 `1 个 RTT`。
3. **HTTP 请求及响应传输**：每次传输都受到 TCP 拥塞控制的影响，最初的发送窗口为 MSS，逐步增大，直到达到带宽限制
4. **引用资源请求**：**非流水线模式下**，每次只能在收到前一个响应后才能发送下一个请求，因此每次引用资源请求都会引发一个 RTT
5. **TCP 四次挥手**：释放连接需消耗 `1 个 RTT`。

![](./images/Pasted%20image%2020241022113218.png)
